{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/documentation/source/css/docs.scss","path":"css/docs.scss","modified":0,"renderable":1},{"_id":"source/images/github.png","path":"images/github.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/api-controllers.md","hash":"ef10dc848fe68bc434b0f08ba8f090d12d50ff57","modified":1502420991848},{"_id":"source/api-responses.md","hash":"b6156ea32bd7674b68405c38861be4b1a6eacf42","modified":1502421090211},{"_id":"source/api-models.md","hash":"e3845354e50568d7949332d65a3671779c1da6b4","modified":1502421030074},{"_id":"source/api-schemas.md","hash":"b1ba4af66b82c483a3d917a15ebd7ade57b95e40","modified":1502421065844},{"_id":"source/cli.md","hash":"aa27cbcf57cebd122667c349a8de1abdeabc1af6","modified":1502419203918},{"_id":"source/compare-next.md","hash":"0c4d0574ccd87cb18f77d48399fe52b2af367816","modified":1502098721722},{"_id":"source/config-env.md","hash":"8938bd1dbf5166ebfbd7c3e0463d54cfb1588d79","modified":1502421138998},{"_id":"source/config.md","hash":"70d350a54f9e8bedd0ce77c0d41eeec1e63c92cc","modified":1502421109515},{"_id":"source/d-mvc.md","hash":"4fba8cf8b6b687bce6aae676283498f5e1048fe0","modified":1502098774567},{"_id":"source/installation.md","hash":"9884414f5d73f9772cdf65f96c8e243d5458b1ab","modified":1502360223693},{"_id":"source/index.md","hash":"c130b75bb7465973914a813b2c09d88cdb1f437d","modified":1502093177020},{"_id":"source/public.md","hash":"a48a11bbff275095235f6ef5dcabf6dd8bf57091","modified":1502421154827},{"_id":"source/ssr.md","hash":"010242f9d927a0d7c3437fafd02afd0cb7f1cc22","modified":1502099413501},{"_id":"source/tip1-react-init.md","hash":"7037922a57e39dc278c05f2ebb48233f7989621f","modified":1502420574044},{"_id":"source/tip3-inject-global.md","hash":"95df56c7ec1d341d4f65553b4cd3ee1b34253b5c","modified":1502420689853},{"_id":"source/tip2-redux.md","hash":"4f1634c3ba1536e792be8c42c8ebd5babe9aba5a","modified":1502420564848},{"_id":"source/tip4-cluster.md","hash":"d8e16f31de9e99976f6ec5b637d410c87c3bbf3b","modified":1502420878953},{"_id":"source/tip5-debug.md","hash":"3c05129d095577eab4229ba7df25a8c07ec3d3f9","modified":1502420882421},{"_id":"source/tip6-compile.md","hash":"7a4047810e360675d5f18ee69f21e5bf76638403","modified":1502420884653},{"_id":"source/universal.md","hash":"8a018bbb579ca2b1737497cd16f7040b1efd7ec2","modified":1502098748377},{"_id":"source/views-app.md","hash":"5b5bb408f71693041fc7f692a1aa9c43ed7b0cf6","modified":1502421206471},{"_id":"source/views-components.md","hash":"1a9f6980e4b063f99273d133b740910919e14d83","modified":1502421215566},{"_id":"source/views-pages.md","hash":"8ebc160b580c4f0d81bf7b2ee71710feb3ef9a2a","modified":1502421188408},{"_id":"source/views.md","hash":"da3d1e8a2644be851f4fbc66a3cfe8dc456a0713","modified":1502421170601},{"_id":"themes/documentation/_config.yml","hash":"670d6f859f7f380466281ae4ca7028ad29469a72","modified":1463532894000},{"_id":"source/_data/nav.yml","hash":"5921e39a115141595476a4af70b27b9e3aa60d4a","modified":1502431475942},{"_id":"themes/documentation/layout/default.swig","hash":"3fa5f82afa857cc9ff6be31cda88c783e3787f83","modified":1502431646560},{"_id":"themes/documentation/source/css/_code.scss","hash":"944676c08a813c90778ce48a3daf23fb6f18ceea","modified":1463532894000},{"_id":"themes/documentation/source/css/_content.scss","hash":"0fbb951dfb7942f6e5bf2536782894864d610d9e","modified":1463532894000},{"_id":"themes/documentation/source/css/_menu.scss","hash":"a72ba17db23e59dc980e831df2246c015605e92a","modified":1463532894000},{"_id":"themes/documentation/source/css/_typography.scss","hash":"06ac832e3ae656ea47b818e7dc6524fcad71b241","modified":1463532894000},{"_id":"themes/documentation/source/css/docs.scss","hash":"c4185a629de88bd667ce25adaea31b5b1dca19c9","modified":1463532894000},{"_id":"public/cli.html","hash":"a3b2c73693135d07a1d6ab4853ec997e12107190","modified":1502421249599},{"_id":"public/compare-next.html","hash":"0e5e590ffb6957419f58b8b4b0136a4666b11982","modified":1502421249604},{"_id":"public/installation.html","hash":"26d183934137ff2dccf3007826960933c09c8729","modified":1502421249604},{"_id":"public/index.html","hash":"a473a14aa17624381098a54391e816e83b497052","modified":1502421249605},{"_id":"public/ssr.html","hash":"9d71079a9f5eefd4f3f919f6647cefc3cd917043","modified":1502421249605},{"_id":"public/d-mvc.html","hash":"9959c03b061aff30a8c924027a6ec00cbfbd9a80","modified":1502421249605},{"_id":"public/universal.html","hash":"1d4fc3e9d5d7be143e295d9a98f264d0984232b5","modified":1502421249605},{"_id":"public/api-controllers.html","hash":"5627d992121353d0661a8627957f4ef8b30c9b3b","modified":1502421249611},{"_id":"public/api-schemas.html","hash":"4c4ed334c9785420ec3ad84936f951c2c252fbe0","modified":1502421249611},{"_id":"public/api-responses.html","hash":"4c30aa1978cc39cc0ab8f34e034abb3935c8a3ac","modified":1502421249611},{"_id":"public/config.html","hash":"8783b16911d0084e259ea9d392bcfabc2c511e8d","modified":1502421249611},{"_id":"public/api-models.html","hash":"143c87463fb640c74c403f97fe6f31dce11ebdf5","modified":1502421249611},{"_id":"public/config-env.html","hash":"865cce3f1ef0ffc7587673c6d7d1e4909e59aa2d","modified":1502421249612},{"_id":"public/public.html","hash":"07a01291d794d9446acadf4a9be7b235a3e0a86c","modified":1502421249612},{"_id":"public/tip1-react-init.html","hash":"6a0581ff5c80f1320b073565365364256083363d","modified":1502421249612},{"_id":"public/tip3-inject-global.html","hash":"dca7f679de3ab5b4f7e93cfcecdc0c8ddb56cfef","modified":1502421249612},{"_id":"public/tip4-cluster.html","hash":"4a243f679f9076702ab09739eb49b6336daf3e69","modified":1502421249612},{"_id":"public/tip5-debug.html","hash":"8c0b734283cb4ff3de4d001cd011a273c9660ccd","modified":1502421249612},{"_id":"public/tip6-compile.html","hash":"fa06273d7baf4fe3f6ac0fd501ccd47a503c5299","modified":1502421249612},{"_id":"public/tip2-redux.html","hash":"f743708c123057ab0b003184e594b75e43043ee5","modified":1502421249612},{"_id":"public/views-app.html","hash":"3957cbdd8b2d8740470fe47068ed58dcb9207e73","modified":1502421249612},{"_id":"public/views-components.html","hash":"08d836bd1337c250cb5cd031785152c7c5a267cc","modified":1502421249612},{"_id":"public/views-pages.html","hash":"3dc61c428da3bc8febce4f63b0ad805dd18d5eea","modified":1502421249612},{"_id":"public/views.html","hash":"282ac0af5649bf0ba1bcfc9f22151303c7fa9ffa","modified":1502421249612},{"_id":"public/css/docs.css","hash":"a23a2d81df4dc95ed88cf5d9942861bb172ede8e","modified":1502421249624},{"_id":"source/images/github.png","hash":"fabe53eb72f9b6d3d47cd95aff31ffc45c2fdbf8","modified":1366004970000}],"Category":[],"Data":[{"_id":"nav","data":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api","title":"api","items":[{"id":"api-controllers","title":"controllers"},{"id":"api-models","title":"models"},{"id":"api-schemas","title":"schemas"},{"id":"api-responses","title":"responses"}]},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}],"Page":[{"layout":"default","id":"api-controllers","title":"api/controllers","next":"api-models.html","_content":"","source":"api-controllers.md","raw":"---\nlayout: default\nid: api-controllers\ntitle: api/controllers\nnext: api-models.html\n---","date":"2017-08-11T03:09:51.848Z","updated":"2017-08-11T03:09:51.848Z","path":"api-controllers.html","comments":1,"_id":"cj67atjcq0000n4iv7tjj3rfc","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"api-schemas","title":"api/schemas","prev":"api-models.html","next":"api-responses.html","_content":"","source":"api-schemas.md","raw":"---\nlayout: default\nid: api-schemas\ntitle: api/schemas\nprev: api-models.html\nnext: api-responses.html\n---","date":"2017-08-11T03:11:05.844Z","updated":"2017-08-11T03:11:05.844Z","path":"api-schemas.html","comments":1,"_id":"cj67atjcr0001n4ivhpdcaxxk","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"api-responses","title":"api/responses","prev":"api-schemas.html","next":"config.html","_content":"","source":"api-responses.md","raw":"---\nlayout: default\nid: api-responses\ntitle: api/responses\nprev: api-schemas.html\nnext: config.html\n---","date":"2017-08-11T03:11:30.211Z","updated":"2017-08-11T03:11:30.211Z","path":"api-responses.html","comments":1,"_id":"cj67atjcs0002n4ivz1ugztfd","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"cli","title":"Cli命令","prev":"installation.html","_content":"\nkoa-cola提供了一些有用的cli命令，包括新建项目、启动项目、生成model schema文件\n\n### 创建koa-cola项目\n\n`koa-cola new app` 或者 `koa-cola n app` 在当前目录创建文件夹名字为app的模版项目，并自动安装依赖，和自动build bundle和启动应用。\n\n### 启动应用\n\n`koa-cola` 在项目目录里面执行，启动项目，node端启动app项目，但是不会build bundle\n\n`koa-cola cheer` 或者 `koa-cola c` 先build bundle，再launch app\n\n### build bundle\n\n`koa-cola build` 执行build命令，会自动寻找controller，并通过controller找到view，最后生成Provider，这个Provider会是webapck build js bundle的入口。\n\n**注意：这将会覆盖你的view/app.tsx**\n\n如果你需要维护你的app.tsx，那么你需要运行webpack命令而不是`koa-cola build`\n\n### 生成model schema文件\n\n`koa-cola schema` 或者 `koa-cola s` 生成`api/schenmas`下面的model schema定义，保存在`typings/schema.ts`\n\n","source":"cli.md","raw":"---\nlayout: default\nid: cli\ntitle: Cli命令\nprev: installation.html\n---\n\nkoa-cola提供了一些有用的cli命令，包括新建项目、启动项目、生成model schema文件\n\n### 创建koa-cola项目\n\n`koa-cola new app` 或者 `koa-cola n app` 在当前目录创建文件夹名字为app的模版项目，并自动安装依赖，和自动build bundle和启动应用。\n\n### 启动应用\n\n`koa-cola` 在项目目录里面执行，启动项目，node端启动app项目，但是不会build bundle\n\n`koa-cola cheer` 或者 `koa-cola c` 先build bundle，再launch app\n\n### build bundle\n\n`koa-cola build` 执行build命令，会自动寻找controller，并通过controller找到view，最后生成Provider，这个Provider会是webapck build js bundle的入口。\n\n**注意：这将会覆盖你的view/app.tsx**\n\n如果你需要维护你的app.tsx，那么你需要运行webpack命令而不是`koa-cola build`\n\n### 生成model schema文件\n\n`koa-cola schema` 或者 `koa-cola s` 生成`api/schenmas`下面的model schema定义，保存在`typings/schema.ts`\n\n","date":"2017-08-11T02:40:03.918Z","updated":"2017-08-11T02:40:03.918Z","path":"cli.html","comments":1,"_id":"cj67atjcs0003n4ivdyyiqbw2","content":"<p>koa-cola提供了一些有用的cli命令，包括新建项目、启动项目、生成model schema文件</p>\n<h3 id=\"创建koa-cola项目\"><a href=\"#创建koa-cola项目\" class=\"headerlink\" title=\"创建koa-cola项目\"></a>创建koa-cola项目</h3><p><code>koa-cola new app</code> 或者 <code>koa-cola n app</code> 在当前目录创建文件夹名字为app的模版项目，并自动安装依赖，和自动build bundle和启动应用。</p>\n<h3 id=\"启动应用\"><a href=\"#启动应用\" class=\"headerlink\" title=\"启动应用\"></a>启动应用</h3><p><code>koa-cola</code> 在项目目录里面执行，启动项目，node端启动app项目，但是不会build bundle</p>\n<p><code>koa-cola cheer</code> 或者 <code>koa-cola c</code> 先build bundle，再launch app</p>\n<h3 id=\"build-bundle\"><a href=\"#build-bundle\" class=\"headerlink\" title=\"build bundle\"></a>build bundle</h3><p><code>koa-cola build</code> 执行build命令，会自动寻找controller，并通过controller找到view，最后生成Provider，这个Provider会是webapck build js bundle的入口。</p>\n<p><strong>注意：这将会覆盖你的view/app.tsx</strong></p>\n<p>如果你需要维护你的app.tsx，那么你需要运行webpack命令而不是<code>koa-cola build</code></p>\n<h3 id=\"生成model-schema文件\"><a href=\"#生成model-schema文件\" class=\"headerlink\" title=\"生成model schema文件\"></a>生成model schema文件</h3><p><code>koa-cola schema</code> 或者 <code>koa-cola s</code> 生成<code>api/schenmas</code>下面的model schema定义，保存在<code>typings/schema.ts</code></p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>koa-cola提供了一些有用的cli命令，包括新建项目、启动项目、生成model schema文件</p>\n<h3 id=\"创建koa-cola项目\"><a href=\"#创建koa-cola项目\" class=\"headerlink\" title=\"创建koa-cola项目\"></a>创建koa-cola项目</h3><p><code>koa-cola new app</code> 或者 <code>koa-cola n app</code> 在当前目录创建文件夹名字为app的模版项目，并自动安装依赖，和自动build bundle和启动应用。</p>\n<h3 id=\"启动应用\"><a href=\"#启动应用\" class=\"headerlink\" title=\"启动应用\"></a>启动应用</h3><p><code>koa-cola</code> 在项目目录里面执行，启动项目，node端启动app项目，但是不会build bundle</p>\n<p><code>koa-cola cheer</code> 或者 <code>koa-cola c</code> 先build bundle，再launch app</p>\n<h3 id=\"build-bundle\"><a href=\"#build-bundle\" class=\"headerlink\" title=\"build bundle\"></a>build bundle</h3><p><code>koa-cola build</code> 执行build命令，会自动寻找controller，并通过controller找到view，最后生成Provider，这个Provider会是webapck build js bundle的入口。</p>\n<p><strong>注意：这将会覆盖你的view/app.tsx</strong></p>\n<p>如果你需要维护你的app.tsx，那么你需要运行webpack命令而不是<code>koa-cola build</code></p>\n<h3 id=\"生成model-schema文件\"><a href=\"#生成model-schema文件\" class=\"headerlink\" title=\"生成model schema文件\"></a>生成model schema文件</h3><p><code>koa-cola schema</code> 或者 <code>koa-cola s</code> 生成<code>api/schenmas</code>下面的model schema定义，保存在<code>typings/schema.ts</code></p>\n"},{"layout":"default","id":"compare-next","title":"对比next.js","prev":"ssr.html","next":"universal.html","_content":"\n[next.js](https://github.com/zeit/next.js)是一个比较流行的也是基于react的SSR的应用框架，不过在react技术栈，next.js支持component和react-router，并没有集成redux，在服务器端，也没有太多支持，比如controller层和express/koa中间件，服务器端只是支持简单的路由、静态页面等，koa-cola则是提供前后端完整的解决方案的框架。\n\n## 数据初始化对比\n\n在数据初始化，两者有点类似，next.js使用静态方法getInitialProps来初始化数据：\n\n```javascript\nimport React from 'react'\nexport default class extends React.Component {\n  static async getInitialProps ({ req }) {\n    return req\n      ? { userAgent: req.headers['user-agent'] }\n      : { userAgent: navigator.userAgent }\n  }\n  render () {\n    return <div>\n      Hello World {this.props.userAgent}\n    </div>\n  }\n}\n```\n\nkoa-cola提供[两种方式](#tips-1-初始化react组件数据)来进行数据初始化，更加灵活。\n\n## 子组件初始化\n\nnext.js不支持子组件的数据初始化：\n\n> Note: getInitialProps can not be used in children components. Only in pages.\n\nkoa-cola则只需要加上decorator \"include\", 完全支持所有的子组件的数据初始化。\n\n```javascript\nimport * as React from 'react';\n\nvar {\n  asyncConnect,\n  include\n} = require('koa-cola').Decorators.view;\n// Child1, Child2 是asyncConnect的组件，并且会进行数据初始化\nvar Child1 = require('../components/child1').default;\nvar Child2 = require('../components/child2').default;\n\nexport interface Props {}\nexport interface States {}\n\n@asyncConnect([])\n@include({\n  Child1,\n  Child2\n})\nclass MultiChildren extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>\n        <Child1 {...this.props} />\n        <Child2 {...this.props} />\n      </div>\n  }\n}\n\nexport default MultiChildren;\n\n```\n\nkoa-cola不但可以支持component的数据初始化，还可以合并page和component的reducer，使用同一个store，page和component的redux无缝结合。详细可参考[多子组件的redux页面例子源码](https://github.com/hcnode/koa-cola/blob/master/app_test/views/pages/multiChildren.tsx)和[在线Demo](http://koa-cola.com:3001/multiChildren)\n\n","source":"compare-next.md","raw":"---\nlayout: default\nid: compare-next\ntitle: 对比next.js\nprev: ssr.html\nnext: universal.html\n---\n\n[next.js](https://github.com/zeit/next.js)是一个比较流行的也是基于react的SSR的应用框架，不过在react技术栈，next.js支持component和react-router，并没有集成redux，在服务器端，也没有太多支持，比如controller层和express/koa中间件，服务器端只是支持简单的路由、静态页面等，koa-cola则是提供前后端完整的解决方案的框架。\n\n## 数据初始化对比\n\n在数据初始化，两者有点类似，next.js使用静态方法getInitialProps来初始化数据：\n\n```javascript\nimport React from 'react'\nexport default class extends React.Component {\n  static async getInitialProps ({ req }) {\n    return req\n      ? { userAgent: req.headers['user-agent'] }\n      : { userAgent: navigator.userAgent }\n  }\n  render () {\n    return <div>\n      Hello World {this.props.userAgent}\n    </div>\n  }\n}\n```\n\nkoa-cola提供[两种方式](#tips-1-初始化react组件数据)来进行数据初始化，更加灵活。\n\n## 子组件初始化\n\nnext.js不支持子组件的数据初始化：\n\n> Note: getInitialProps can not be used in children components. Only in pages.\n\nkoa-cola则只需要加上decorator \"include\", 完全支持所有的子组件的数据初始化。\n\n```javascript\nimport * as React from 'react';\n\nvar {\n  asyncConnect,\n  include\n} = require('koa-cola').Decorators.view;\n// Child1, Child2 是asyncConnect的组件，并且会进行数据初始化\nvar Child1 = require('../components/child1').default;\nvar Child2 = require('../components/child2').default;\n\nexport interface Props {}\nexport interface States {}\n\n@asyncConnect([])\n@include({\n  Child1,\n  Child2\n})\nclass MultiChildren extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>\n        <Child1 {...this.props} />\n        <Child2 {...this.props} />\n      </div>\n  }\n}\n\nexport default MultiChildren;\n\n```\n\nkoa-cola不但可以支持component的数据初始化，还可以合并page和component的reducer，使用同一个store，page和component的redux无缝结合。详细可参考[多子组件的redux页面例子源码](https://github.com/hcnode/koa-cola/blob/master/app_test/views/pages/multiChildren.tsx)和[在线Demo](http://koa-cola.com:3001/multiChildren)\n\n","date":"2017-08-07T09:38:41.722Z","updated":"2017-08-07T09:38:41.722Z","path":"compare-next.html","comments":1,"_id":"cj67atjct0004n4ivzkmko6ub","content":"<p><a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"external\">next.js</a>是一个比较流行的也是基于react的SSR的应用框架，不过在react技术栈，next.js支持component和react-router，并没有集成redux，在服务器端，也没有太多支持，比如controller层和express/koa中间件，服务器端只是支持简单的路由、静态页面等，koa-cola则是提供前后端完整的解决方案的框架。</p>\n<h2 id=\"数据初始化对比\"><a href=\"#数据初始化对比\" class=\"headerlink\" title=\"数据初始化对比\"></a>数据初始化对比</h2><p>在数据初始化，两者有点类似，next.js使用静态方法getInitialProps来初始化数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> getInitialProps (&#123; req &#125;) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> req</div><div class=\"line\">      ? &#123; <span class=\"attr\">userAgent</span>: req.headers[<span class=\"string\">'user-agent'</span>] &#125;</div><div class=\"line\">      : &#123; <span class=\"attr\">userAgent</span>: navigator.userAgent &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render () &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">      Hello World &#123;this.props.userAgent&#125;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>koa-cola提供<a href=\"#tips-1-初始化react组件数据\">两种方式</a>来进行数据初始化，更加灵活。</p>\n<h2 id=\"子组件初始化\"><a href=\"#子组件初始化\" class=\"headerlink\" title=\"子组件初始化\"></a>子组件初始化</h2><p>next.js不支持子组件的数据初始化：</p>\n<blockquote>\n<p>Note: getInitialProps can not be used in children components. Only in pages.</p>\n</blockquote>\n<p>koa-cola则只需要加上decorator “include”, 完全支持所有的子组件的数据初始化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">  asyncConnect,</div><div class=\"line\">  include</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\"><span class=\"comment\">// Child1, Child2 是asyncConnect的组件，并且会进行数据初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> Child1 = <span class=\"built_in\">require</span>(<span class=\"string\">'../components/child1'</span>).default;</div><div class=\"line\"><span class=\"keyword\">var</span> Child2 = <span class=\"built_in\">require</span>(<span class=\"string\">'../components/child2'</span>).default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> interface Props &#123;&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> interface States &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">@asyncConnect([])</div><div class=\"line\">@include(&#123;</div><div class=\"line\">  Child1,</div><div class=\"line\">  Child2</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiChildren</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">        &lt;Child1 &#123;...this.props&#125; /&gt;</div><div class=\"line\">        &lt;Child2 &#123;...this.props&#125; /&gt;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">export default MultiChildren;</div></pre></td></tr></table></figure>\n<p>koa-cola不但可以支持component的数据初始化，还可以合并page和component的reducer，使用同一个store，page和component的redux无缝结合。详细可参考<a href=\"https://github.com/hcnode/koa-cola/blob/master/app_test/views/pages/multiChildren.tsx\" target=\"_blank\" rel=\"external\">多子组件的redux页面例子源码</a>和<a href=\"http://koa-cola.com:3001/multiChildren\" target=\"_blank\" rel=\"external\">在线Demo</a></p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p><a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"external\">next.js</a>是一个比较流行的也是基于react的SSR的应用框架，不过在react技术栈，next.js支持component和react-router，并没有集成redux，在服务器端，也没有太多支持，比如controller层和express/koa中间件，服务器端只是支持简单的路由、静态页面等，koa-cola则是提供前后端完整的解决方案的框架。</p>\n<h2 id=\"数据初始化对比\"><a href=\"#数据初始化对比\" class=\"headerlink\" title=\"数据初始化对比\"></a>数据初始化对比</h2><p>在数据初始化，两者有点类似，next.js使用静态方法getInitialProps来初始化数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> getInitialProps (&#123; req &#125;) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> req</div><div class=\"line\">      ? &#123; <span class=\"attr\">userAgent</span>: req.headers[<span class=\"string\">'user-agent'</span>] &#125;</div><div class=\"line\">      : &#123; <span class=\"attr\">userAgent</span>: navigator.userAgent &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render () &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">      Hello World &#123;this.props.userAgent&#125;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>koa-cola提供<a href=\"#tips-1-初始化react组件数据\">两种方式</a>来进行数据初始化，更加灵活。</p>\n<h2 id=\"子组件初始化\"><a href=\"#子组件初始化\" class=\"headerlink\" title=\"子组件初始化\"></a>子组件初始化</h2><p>next.js不支持子组件的数据初始化：</p>\n<blockquote>\n<p>Note: getInitialProps can not be used in children components. Only in pages.</p>\n</blockquote>\n<p>koa-cola则只需要加上decorator “include”, 完全支持所有的子组件的数据初始化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">  asyncConnect,</div><div class=\"line\">  include</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\"><span class=\"comment\">// Child1, Child2 是asyncConnect的组件，并且会进行数据初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> Child1 = <span class=\"built_in\">require</span>(<span class=\"string\">'../components/child1'</span>).default;</div><div class=\"line\"><span class=\"keyword\">var</span> Child2 = <span class=\"built_in\">require</span>(<span class=\"string\">'../components/child2'</span>).default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> interface Props &#123;&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> interface States &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">@asyncConnect([])</div><div class=\"line\">@include(&#123;</div><div class=\"line\">  Child1,</div><div class=\"line\">  Child2</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiChildren</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">        &lt;Child1 &#123;...this.props&#125; /&gt;</div><div class=\"line\">        &lt;Child2 &#123;...this.props&#125; /&gt;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">export default MultiChildren;</div></pre></td></tr></table></figure>\n<p>koa-cola不但可以支持component的数据初始化，还可以合并page和component的reducer，使用同一个store，page和component的redux无缝结合。详细可参考<a href=\"https://github.com/hcnode/koa-cola/blob/master/app_test/views/pages/multiChildren.tsx\" target=\"_blank\" rel=\"external\">多子组件的redux页面例子源码</a>和<a href=\"http://koa-cola.com:3001/multiChildren\" target=\"_blank\" rel=\"external\">在线Demo</a></p>\n"},{"layout":"default","id":"config","title":"config","prev":"api-responses.html","next":"config-env.html","_content":"","source":"config.md","raw":"---\nlayout: default\nid: config\ntitle: config\nprev: api-responses.html\nnext: config-env.html\n---","date":"2017-08-11T03:11:49.515Z","updated":"2017-08-11T03:11:49.515Z","path":"config.html","comments":1,"_id":"cj67atjcu0005n4ivcyyh1m1y","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"api-models","title":"api/models","prev":"api-controllers.html","next":"api-schemas.html","_content":"","source":"api-models.md","raw":"---\nlayout: default\nid: api-models\ntitle: api/models\nprev: api-controllers.html\nnext: api-schemas.html\n---","date":"2017-08-11T03:10:30.074Z","updated":"2017-08-11T03:10:30.074Z","path":"api-models.html","comments":1,"_id":"cj67atjcv0006n4ivygh7cget","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"d-mvc","title":"decorator的mvc开发模式","prev":"universal.html","next":"installation.html","_content":"\nkoa-cola可以使用es7的decorator装饰器开发模式来写mvc，controller是必须用提供的decorator来开发（因为涉及到router相关的定义），model和view层则没有强制需要demo所演示的decorator来开发。\n### Controller\n    \n使用decorator装饰器来注入相关依赖，路由层的decorators包括router、中间件、response、view，响应阶段的decorators包括koa.Context、param、response、request等，比如以下例子：\n```javascript\nvar { Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response } = require('koa-cola').Decorators.controller;\n@Controller('') \nclass FooController {\n    @Get('/some_api')  // 定义router以及method\n    @Response(Ok)       // 定义数据返回的结构\n    some_api (@Ctx() ctx, @QueryParam() param : any) { // 注入ctx和param\n        // 初始化数据，数据将会以“Ok”定义的格式返回\n        return {\n            foo : 'bar'\n        }\n    }\n\n    @Get('/some_page')  // 定义router以及method\n    @View('some_page')\n    some_page (@Ctx() ctx, @QueryParam() param : any) { // 注入ctx和param\n        // 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo\n        return {\n            foo : 'bar'\n        }\n    }\n}\n```    \n\n    因为使用decorator定义router，所以在koa-cola里面不需要单独定义router。\n\n### View\n\nview层可以是简单的React.Component或者是stateless的函数组件，也可以是使用官方的react-redux封装过的组件，todolist demo的view则是使用了[redux-connect](https://github.com/makeomatic/redux-connect) 提供的decorator(当然你也可以直接用它的connect方法)，redux-connect也是基于react-redux，以下是view层支持的react组件类型。\n    \n1. React.Component组件\n\n```javascript\n    class Index extends React.Component<Props, States>   {\n        constructor(props: Props) {\n            super(props);\n        }\n        static defaultProps = {\n            \n        };\n        render() {\n            return <h1>Wow koa-cola!</h1>\n        }\n    };\n    export default Index\n```\n\n2. stateless组件\n\n```javascript\n    export default function({some_props}) {\n        return <h1>Wow koa-cola!</h1>\n    }\n```\n\n3. react-redux组件\n\n```javascript\n    import { connect } from 'react-redux'\n    var Index = function({some_props}) {\n        return <h1>Wow koa-cola!</h1>\n    }\n    export default connect(\n        mapStateToProps,\n        mapDispatchToProps\n    )(Index)\n```\n\n4. redux-connect的decorator\n使用这种方式的话，需要注意两点：\n    * redux的reducer需要使用装饰器colaReducer\n    * 如果有子组件也是使用redux-connect封装，则需要使用装饰器include\n    * 以上两点可以参考todolist的[代码](https://github.com/koa-cola/todolist/blob/master/views/pages/colastyleDemo.tsx)\n\n```javascript\nimport AddTodo from '../official-demo/containers/AddTodo';\nimport FilterLink from '../official-demo/containers/FilterLink';\nimport VisibleTodoList from '../official-demo/containers/VisibleTodoList';\nvar {\n  asyncConnect,\n  colaReducer,\n  include\n} = require('koa-cola').Decorators.view;\n@asyncConnect([\n  {\n    key: 'todosData',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n      var api = new GetTodoList({});\n      var data = await api.fetch(helpers.ctx);\n      dispatch({\n        type: 'INIT_TODO',\n        data: data.result.result\n      });\n      return data.result.result;\n    }\n  }\n])\n@colaReducer({\n  todos,\n  visibilityFilter\n})\n@include({ AddTodo, FilterLink, VisibleTodoList })\nclass ColastyleDemo extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <App />;\n  }\n}\nexport default ColastyleDemo;\n```\n\n5. 自定义header和bundle方式\n\nkoa-cola渲染页面时，默认会找views/pages/layout.ts封装页面的html，如果没有这个layout文件，则直接输出page组件的html，如果view组件使用了doNotUseLayout decorator，则页面不会使用layout.ts输出，这时你可以自定义header和bundle的decorator。\n\n```javascript\nimport * as React from 'react';\nvar {\n  header, bundle, doNotUseLayout\n} = require('../../../dist').Decorators.view;\n@doNotUseLayout\n@bundle([\n  \"/bundle.js\",\n  \"/test.js\"\n])\n@header(() => {\n  return <head>\n    <meta name=\"viewport\" content=\"width=device-width\" />\n  </head>\n})\nfunction Page (){\n  return <h1>koa-cola</h1>\n};\nexport default Page\n```\n\n### Model\n和必须使用decorator的controller层、必须使用react组件的view层不一样，model层是完全没有耦合，你可以使用任何你喜欢的orm或者odm，或者不需要model层也可以，不过使用koa-cola风格的来写model，你可以体验不一样的开发模式。\n\n1. 你可以直接在目录api/models下创建如user.ts：\n```javascript\nimport * as mongoose from 'mongoose'\nexport default mongoose.model('user', new mongoose.Schema({\n    name : String,\n    email : String\n}))\n```\n\n然后就可以在其他代码里面使用：\n```javascript\nvar user = await app.models.user.find({name : 'harry'})\n```\n\n2. 使用koa-cola的风格写model\n\n首先在`api/schemas`目录创建user.ts\n\n```javascript\nexport const userSchema = function(mongoose){\n    return {\n        name: {\n            type : String\n        },\n        email : {\n            type : String\n        }\n    }\n}\n```\n\n在目录`api/models`下创建model如user.ts：\n```javascript\nimport * as mongoose from 'mongoose'\nimport userSchema from '../schemas/user'\nexport default mongoose.model('user', new mongoose.Schema(userSchema(mongoose)))\n```\n\n当然也可以使用decorator方式定义model，还可以定义相关hook，详情可以参考[mongoose-decorators](https://github.com/aksyonov/mongoose-decorators)\n\n```javascript\nimport { todoListSchema } from '../schemas/todoList';\nvar { model } = app.decorators.model;\n\n@model(todoListSchema(app.mongoose))\nexport default class TodoList {}\n```\n\n使用cli生成model的schema\n\n`koa-cola --schema` 自动生成model的接口定义在`typings/schema.ts`\n\n然后你可以在代码通过使用typescript的类型定义，享受vscode的intellisense带来的乐趣\n```javascript\nimport {userSchema} from './typings/schema' \nvar user : userSchema = await app.models.user.find({name : 'harry'})\n```\n\n在前面提到的为什么需要在api/schemas定义model的schema，除了上面可以自动生成schema的接口，这部分可以在浏览器端代码复用，比如数据Validate。详细可以查看[文档](http://mongoosejs.com/docs/browser.html)\n\n3. koa-cola提供了前后端universal的api接口定义，比如todolist demo的获取数据的接口定义\n\n```javascript\nimport { todoListSchema } from './typings/schema';\nimport { ApiBase, apiFetch } from 'koa-cola';\n\nexport class GetTodoList extends ApiBase<\n  {\n      // 参数类型\n  },\n  {\n    code: number;\n    result: [todoListSchema];\n  },\n  {\n      // 异常定义\n  }\n> {\n  constructor(body) {\n    super(body);\n  }\n  url: string = '/api/getTodoList';\n  method: string = 'get';\n}\n```\n\n在代码里面使用api，并享受ts带来的乐趣：\n```javascript\nvar api = new GetTodoList({});\nvar data = await api.fetch(helpers.ctx);\n```\n\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api1.png\" alt=\"Drawing\" width=\"600\"/>\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api2.png\" alt=\"Drawing\" width=\"600\"/>\n\n又比如参数body的定义，如果定义了必传参数，调用时候没有传，则vscode会提示错误\n```javascript\nimport { testSchema } from './typings/schema';\nimport { ApiBase, apiFetch } from 'koa-cola'\nexport interface ComposeBody{\n    foo : string,\n    bar? : number\n}\nexport class Compose extends ApiBase<ComposeBody, testSchema, {}>{\n    constructor(body : ComposeBody){\n        super(body)\n    }\n    url : string = '/compose'\n    method : string = 'post'\n}\n```\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api3.png\" alt=\"Drawing\" width=\"600\"/>\n","source":"d-mvc.md","raw":"---\nlayout: default\nid: d-mvc\ntitle: decorator的mvc开发模式\nprev: universal.html\nnext: installation.html\n---\n\nkoa-cola可以使用es7的decorator装饰器开发模式来写mvc，controller是必须用提供的decorator来开发（因为涉及到router相关的定义），model和view层则没有强制需要demo所演示的decorator来开发。\n### Controller\n    \n使用decorator装饰器来注入相关依赖，路由层的decorators包括router、中间件、response、view，响应阶段的decorators包括koa.Context、param、response、request等，比如以下例子：\n```javascript\nvar { Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response } = require('koa-cola').Decorators.controller;\n@Controller('') \nclass FooController {\n    @Get('/some_api')  // 定义router以及method\n    @Response(Ok)       // 定义数据返回的结构\n    some_api (@Ctx() ctx, @QueryParam() param : any) { // 注入ctx和param\n        // 初始化数据，数据将会以“Ok”定义的格式返回\n        return {\n            foo : 'bar'\n        }\n    }\n\n    @Get('/some_page')  // 定义router以及method\n    @View('some_page')\n    some_page (@Ctx() ctx, @QueryParam() param : any) { // 注入ctx和param\n        // 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo\n        return {\n            foo : 'bar'\n        }\n    }\n}\n```    \n\n    因为使用decorator定义router，所以在koa-cola里面不需要单独定义router。\n\n### View\n\nview层可以是简单的React.Component或者是stateless的函数组件，也可以是使用官方的react-redux封装过的组件，todolist demo的view则是使用了[redux-connect](https://github.com/makeomatic/redux-connect) 提供的decorator(当然你也可以直接用它的connect方法)，redux-connect也是基于react-redux，以下是view层支持的react组件类型。\n    \n1. React.Component组件\n\n```javascript\n    class Index extends React.Component<Props, States>   {\n        constructor(props: Props) {\n            super(props);\n        }\n        static defaultProps = {\n            \n        };\n        render() {\n            return <h1>Wow koa-cola!</h1>\n        }\n    };\n    export default Index\n```\n\n2. stateless组件\n\n```javascript\n    export default function({some_props}) {\n        return <h1>Wow koa-cola!</h1>\n    }\n```\n\n3. react-redux组件\n\n```javascript\n    import { connect } from 'react-redux'\n    var Index = function({some_props}) {\n        return <h1>Wow koa-cola!</h1>\n    }\n    export default connect(\n        mapStateToProps,\n        mapDispatchToProps\n    )(Index)\n```\n\n4. redux-connect的decorator\n使用这种方式的话，需要注意两点：\n    * redux的reducer需要使用装饰器colaReducer\n    * 如果有子组件也是使用redux-connect封装，则需要使用装饰器include\n    * 以上两点可以参考todolist的[代码](https://github.com/koa-cola/todolist/blob/master/views/pages/colastyleDemo.tsx)\n\n```javascript\nimport AddTodo from '../official-demo/containers/AddTodo';\nimport FilterLink from '../official-demo/containers/FilterLink';\nimport VisibleTodoList from '../official-demo/containers/VisibleTodoList';\nvar {\n  asyncConnect,\n  colaReducer,\n  include\n} = require('koa-cola').Decorators.view;\n@asyncConnect([\n  {\n    key: 'todosData',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n      var api = new GetTodoList({});\n      var data = await api.fetch(helpers.ctx);\n      dispatch({\n        type: 'INIT_TODO',\n        data: data.result.result\n      });\n      return data.result.result;\n    }\n  }\n])\n@colaReducer({\n  todos,\n  visibilityFilter\n})\n@include({ AddTodo, FilterLink, VisibleTodoList })\nclass ColastyleDemo extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <App />;\n  }\n}\nexport default ColastyleDemo;\n```\n\n5. 自定义header和bundle方式\n\nkoa-cola渲染页面时，默认会找views/pages/layout.ts封装页面的html，如果没有这个layout文件，则直接输出page组件的html，如果view组件使用了doNotUseLayout decorator，则页面不会使用layout.ts输出，这时你可以自定义header和bundle的decorator。\n\n```javascript\nimport * as React from 'react';\nvar {\n  header, bundle, doNotUseLayout\n} = require('../../../dist').Decorators.view;\n@doNotUseLayout\n@bundle([\n  \"/bundle.js\",\n  \"/test.js\"\n])\n@header(() => {\n  return <head>\n    <meta name=\"viewport\" content=\"width=device-width\" />\n  </head>\n})\nfunction Page (){\n  return <h1>koa-cola</h1>\n};\nexport default Page\n```\n\n### Model\n和必须使用decorator的controller层、必须使用react组件的view层不一样，model层是完全没有耦合，你可以使用任何你喜欢的orm或者odm，或者不需要model层也可以，不过使用koa-cola风格的来写model，你可以体验不一样的开发模式。\n\n1. 你可以直接在目录api/models下创建如user.ts：\n```javascript\nimport * as mongoose from 'mongoose'\nexport default mongoose.model('user', new mongoose.Schema({\n    name : String,\n    email : String\n}))\n```\n\n然后就可以在其他代码里面使用：\n```javascript\nvar user = await app.models.user.find({name : 'harry'})\n```\n\n2. 使用koa-cola的风格写model\n\n首先在`api/schemas`目录创建user.ts\n\n```javascript\nexport const userSchema = function(mongoose){\n    return {\n        name: {\n            type : String\n        },\n        email : {\n            type : String\n        }\n    }\n}\n```\n\n在目录`api/models`下创建model如user.ts：\n```javascript\nimport * as mongoose from 'mongoose'\nimport userSchema from '../schemas/user'\nexport default mongoose.model('user', new mongoose.Schema(userSchema(mongoose)))\n```\n\n当然也可以使用decorator方式定义model，还可以定义相关hook，详情可以参考[mongoose-decorators](https://github.com/aksyonov/mongoose-decorators)\n\n```javascript\nimport { todoListSchema } from '../schemas/todoList';\nvar { model } = app.decorators.model;\n\n@model(todoListSchema(app.mongoose))\nexport default class TodoList {}\n```\n\n使用cli生成model的schema\n\n`koa-cola --schema` 自动生成model的接口定义在`typings/schema.ts`\n\n然后你可以在代码通过使用typescript的类型定义，享受vscode的intellisense带来的乐趣\n```javascript\nimport {userSchema} from './typings/schema' \nvar user : userSchema = await app.models.user.find({name : 'harry'})\n```\n\n在前面提到的为什么需要在api/schemas定义model的schema，除了上面可以自动生成schema的接口，这部分可以在浏览器端代码复用，比如数据Validate。详细可以查看[文档](http://mongoosejs.com/docs/browser.html)\n\n3. koa-cola提供了前后端universal的api接口定义，比如todolist demo的获取数据的接口定义\n\n```javascript\nimport { todoListSchema } from './typings/schema';\nimport { ApiBase, apiFetch } from 'koa-cola';\n\nexport class GetTodoList extends ApiBase<\n  {\n      // 参数类型\n  },\n  {\n    code: number;\n    result: [todoListSchema];\n  },\n  {\n      // 异常定义\n  }\n> {\n  constructor(body) {\n    super(body);\n  }\n  url: string = '/api/getTodoList';\n  method: string = 'get';\n}\n```\n\n在代码里面使用api，并享受ts带来的乐趣：\n```javascript\nvar api = new GetTodoList({});\nvar data = await api.fetch(helpers.ctx);\n```\n\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api1.png\" alt=\"Drawing\" width=\"600\"/>\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api2.png\" alt=\"Drawing\" width=\"600\"/>\n\n又比如参数body的定义，如果定义了必传参数，调用时候没有传，则vscode会提示错误\n```javascript\nimport { testSchema } from './typings/schema';\nimport { ApiBase, apiFetch } from 'koa-cola'\nexport interface ComposeBody{\n    foo : string,\n    bar? : number\n}\nexport class Compose extends ApiBase<ComposeBody, testSchema, {}>{\n    constructor(body : ComposeBody){\n        super(body)\n    }\n    url : string = '/compose'\n    method : string = 'post'\n}\n```\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api3.png\" alt=\"Drawing\" width=\"600\"/>\n","date":"2017-08-07T09:39:34.567Z","updated":"2017-08-07T09:39:34.567Z","path":"d-mvc.html","comments":1,"_id":"cj67atjcw0007n4ivhsan0wop","content":"<p>koa-cola可以使用es7的decorator装饰器开发模式来写mvc，controller是必须用提供的decorator来开发（因为涉及到router相关的定义），model和view层则没有强制需要demo所演示的decorator来开发。</p>\n<h3 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h3><p>使用decorator装饰器来注入相关依赖，路由层的decorators包括router、中间件、response、view，响应阶段的decorators包括koa.Context、param、response、request等，比如以下例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.controller;</div><div class=\"line\">@Controller(<span class=\"string\">''</span>) </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span> </span>&#123;</div><div class=\"line\">    @Get(<span class=\"string\">'/some_api'</span>)  <span class=\"comment\">// 定义router以及method</span></div><div class=\"line\">    @Response(Ok)       <span class=\"comment\">// 定义数据返回的结构</span></div><div class=\"line\">    some_api (@Ctx() ctx, @QueryParam() param : any) &#123; <span class=\"comment\">// 注入ctx和param</span></div><div class=\"line\">        <span class=\"comment\">// 初始化数据，数据将会以“Ok”定义的格式返回</span></div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Get(<span class=\"string\">'/some_page'</span>)  <span class=\"comment\">// 定义router以及method</span></div><div class=\"line\">    @View(<span class=\"string\">'some_page'</span>)</div><div class=\"line\">    some_page (@Ctx() ctx, @QueryParam() param : any) &#123; <span class=\"comment\">// 注入ctx和param</span></div><div class=\"line\">        <span class=\"comment\">// 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo</span></div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">    因为使用decorator定义router，所以在koa-cola里面不需要单独定义router。</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">### View</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">view层可以是简单的React.Component或者是stateless的函数组件，也可以是使用官方的react-redux封装过的组件，todolist demo的view则是使用了[redux-connect](https://github.com/makeomatic/redux-connect) 提供的decorator(当然你也可以直接用它的connect方法)，redux-connect也是基于react-redux，以下是view层支持的react组件类型。</span></div><div class=\"line\"><span class=\"string\">    </span></div><div class=\"line\"><span class=\"string\">1. React.Component组件</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt;   </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(props);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">static</span> defaultProps = &#123;</div><div class=\"line\">            </div><div class=\"line\">        &#125;;</div><div class=\"line\">        render() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> &lt;h1&gt;Wow koa-cola!&lt;/h1&gt;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Index</div></pre></td></tr></table></figure></p>\n<ol>\n<li>stateless组件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;some_props&#125;</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;h1&gt;Wow koa-cola!&lt;/h1&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>react-redux组件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></div><div class=\"line\"><span class=\"keyword\">var</span> Index = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;some_props&#125;</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;h1&gt;Wow koa-cola!&lt;/h1&gt;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</div><div class=\"line\">    mapStateToProps,</div><div class=\"line\">    mapDispatchToProps</div><div class=\"line\">)(Index)</div></pre></td></tr></table></figure>\n<ol>\n<li>redux-connect的decorator<br>使用这种方式的话，需要注意两点：<ul>\n<li>redux的reducer需要使用装饰器colaReducer</li>\n<li>如果有子组件也是使用redux-connect封装，则需要使用装饰器include</li>\n<li>以上两点可以参考todolist的<a href=\"https://github.com/koa-cola/todolist/blob/master/views/pages/colastyleDemo.tsx\" target=\"_blank\" rel=\"external\">代码</a></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> AddTodo <span class=\"keyword\">from</span> <span class=\"string\">'../official-demo/containers/AddTodo'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> FilterLink <span class=\"keyword\">from</span> <span class=\"string\">'../official-demo/containers/FilterLink'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> VisibleTodoList <span class=\"keyword\">from</span> <span class=\"string\">'../official-demo/containers/VisibleTodoList'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">  asyncConnect,</div><div class=\"line\">  colaReducer,</div><div class=\"line\">  include</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'todosData'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\">      <span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div><div class=\"line\">      dispatch(&#123;</div><div class=\"line\">        type: <span class=\"string\">'INIT_TODO'</span>,</div><div class=\"line\">        data: data.result.result</div><div class=\"line\">      &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> data.result.result;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\">@colaReducer(&#123;</div><div class=\"line\">  todos,</div><div class=\"line\">  visibilityFilter</div><div class=\"line\">&#125;)</div><div class=\"line\">@include(&#123; AddTodo, FilterLink, VisibleTodoList &#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColastyleDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;App /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export default ColastyleDemo;</div></pre></td></tr></table></figure>\n<ol>\n<li>自定义header和bundle方式</li>\n</ol>\n<p>koa-cola渲染页面时，默认会找views/pages/layout.ts封装页面的html，如果没有这个layout文件，则直接输出page组件的html，如果view组件使用了doNotUseLayout decorator，则页面不会使用layout.ts输出，这时你可以自定义header和bundle的decorator。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">  header, bundle, doNotUseLayout</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'../../../dist'</span>).Decorators.view;</div><div class=\"line\">@doNotUseLayout</div><div class=\"line\">@bundle([</div><div class=\"line\">  <span class=\"string\">\"/bundle.js\"</span>,</div><div class=\"line\">  <span class=\"string\">\"/test.js\"</span></div><div class=\"line\">])</div><div class=\"line\">@header(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &lt;head&gt;</div><div class=\"line\">    &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt;</div><div class=\"line\">  &lt;/head&gt;</div><div class=\"line\">&#125;)</div><div class=\"line\">function Page ()&#123;</div><div class=\"line\">  return &lt;h1&gt;koa-cola&lt;/h1&gt;</div><div class=\"line\">&#125;;</div><div class=\"line\">export default Page</div></pre></td></tr></table></figure>\n<h3 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h3><p>和必须使用decorator的controller层、必须使用react组件的view层不一样，model层是完全没有耦合，你可以使用任何你喜欢的orm或者odm，或者不需要model层也可以，不过使用koa-cola风格的来写model，你可以体验不一样的开发模式。</p>\n<ol>\n<li>你可以直接在目录api/models下创建如user.ts：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> mongoose <span class=\"keyword\">from</span> <span class=\"string\">'mongoose'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> mongoose.model(<span class=\"string\">'user'</span>, <span class=\"keyword\">new</span> mongoose.Schema(&#123;</div><div class=\"line\">    name : <span class=\"built_in\">String</span>,</div><div class=\"line\">    email : <span class=\"built_in\">String</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后就可以在其他代码里面使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">await</span> app.models.user.find(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'harry'</span>&#125;)</div></pre></td></tr></table></figure></p>\n<ol>\n<li>使用koa-cola的风格写model</li>\n</ol>\n<p>首先在<code>api/schemas</code>目录创建user.ts</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> userSchema = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mongoose</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        name: &#123;</div><div class=\"line\">            type : <span class=\"built_in\">String</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        email : &#123;</div><div class=\"line\">            type : <span class=\"built_in\">String</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在目录<code>api/models</code>下创建model如user.ts：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> mongoose <span class=\"keyword\">from</span> <span class=\"string\">'mongoose'</span></div><div class=\"line\"><span class=\"keyword\">import</span> userSchema <span class=\"keyword\">from</span> <span class=\"string\">'../schemas/user'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> mongoose.model(<span class=\"string\">'user'</span>, <span class=\"keyword\">new</span> mongoose.Schema(userSchema(mongoose)))</div></pre></td></tr></table></figure></p>\n<p>当然也可以使用decorator方式定义model，还可以定义相关hook，详情可以参考<a href=\"https://github.com/aksyonov/mongoose-decorators\" target=\"_blank\" rel=\"external\">mongoose-decorators</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; todoListSchema &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../schemas/todoList'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123; model &#125; = app.decorators.model;</div><div class=\"line\"></div><div class=\"line\">@model(todoListSchema(app.mongoose))</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TodoList</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>使用cli生成model的schema</p>\n<p><code>koa-cola --schema</code> 自动生成model的接口定义在<code>typings/schema.ts</code></p>\n<p>然后你可以在代码通过使用typescript的类型定义，享受vscode的intellisense带来的乐趣<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;userSchema&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./typings/schema'</span> </div><div class=\"line\"><span class=\"keyword\">var</span> user : userSchema = <span class=\"keyword\">await</span> app.models.user.find(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'harry'</span>&#125;)</div></pre></td></tr></table></figure></p>\n<p>在前面提到的为什么需要在api/schemas定义model的schema，除了上面可以自动生成schema的接口，这部分可以在浏览器端代码复用，比如数据Validate。详细可以查看<a href=\"http://mongoosejs.com/docs/browser.html\" target=\"_blank\" rel=\"external\">文档</a></p>\n<ol>\n<li>koa-cola提供了前后端universal的api接口定义，比如todolist demo的获取数据的接口定义</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; todoListSchema &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./typings/schema'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; ApiBase, apiFetch &#125; <span class=\"keyword\">from</span> <span class=\"string\">'koa-cola'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetTodoList</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApiBase</span>&lt;</span></div><div class=\"line\"><span class=\"class\">  </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 参数类型</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    code: number;</div><div class=\"line\">    result: [todoListSchema];</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">      <span class=\"comment\">// 异常定义</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(body) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(body);</div><div class=\"line\">  &#125;</div><div class=\"line\">  url: string = <span class=\"string\">'/api/getTodoList'</span>;</div><div class=\"line\">  method: string = <span class=\"string\">'get'</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在代码里面使用api，并享受ts带来的乐趣：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api1.png\" alt=\"Drawing\" width=\"600\"><br><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api2.png\" alt=\"Drawing\" width=\"600\"></p>\n<p>又比如参数body的定义，如果定义了必传参数，调用时候没有传，则vscode会提示错误<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; testSchema &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./typings/schema'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; ApiBase, apiFetch &#125; <span class=\"keyword\">from</span> <span class=\"string\">'koa-cola'</span></div><div class=\"line\"><span class=\"keyword\">export</span> interface ComposeBody&#123;</div><div class=\"line\">    foo : string,</div><div class=\"line\">    bar? : number</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compose</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApiBase</span>&lt;<span class=\"title\">ComposeBody</span>, <span class=\"title\">testSchema</span>, </span>&#123;&#125;&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(body : ComposeBody)&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(body)</div><div class=\"line\">    &#125;</div><div class=\"line\">    url : string = <span class=\"string\">'/compose'</span></div><div class=\"line\">    method : string = <span class=\"string\">'post'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api3.png\" alt=\"Drawing\" width=\"600\"></p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>koa-cola可以使用es7的decorator装饰器开发模式来写mvc，controller是必须用提供的decorator来开发（因为涉及到router相关的定义），model和view层则没有强制需要demo所演示的decorator来开发。</p>\n<h3 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h3><p>使用decorator装饰器来注入相关依赖，路由层的decorators包括router、中间件、response、view，响应阶段的decorators包括koa.Context、param、response、request等，比如以下例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.controller;</div><div class=\"line\">@Controller(<span class=\"string\">''</span>) </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span> </span>&#123;</div><div class=\"line\">    @Get(<span class=\"string\">'/some_api'</span>)  <span class=\"comment\">// 定义router以及method</span></div><div class=\"line\">    @Response(Ok)       <span class=\"comment\">// 定义数据返回的结构</span></div><div class=\"line\">    some_api (@Ctx() ctx, @QueryParam() param : any) &#123; <span class=\"comment\">// 注入ctx和param</span></div><div class=\"line\">        <span class=\"comment\">// 初始化数据，数据将会以“Ok”定义的格式返回</span></div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Get(<span class=\"string\">'/some_page'</span>)  <span class=\"comment\">// 定义router以及method</span></div><div class=\"line\">    @View(<span class=\"string\">'some_page'</span>)</div><div class=\"line\">    some_page (@Ctx() ctx, @QueryParam() param : any) &#123; <span class=\"comment\">// 注入ctx和param</span></div><div class=\"line\">        <span class=\"comment\">// 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo</span></div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">    因为使用decorator定义router，所以在koa-cola里面不需要单独定义router。</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">### View</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">view层可以是简单的React.Component或者是stateless的函数组件，也可以是使用官方的react-redux封装过的组件，todolist demo的view则是使用了[redux-connect](https://github.com/makeomatic/redux-connect) 提供的decorator(当然你也可以直接用它的connect方法)，redux-connect也是基于react-redux，以下是view层支持的react组件类型。</span></div><div class=\"line\"><span class=\"string\">    </span></div><div class=\"line\"><span class=\"string\">1. React.Component组件</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt;   </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(props);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">static</span> defaultProps = &#123;</div><div class=\"line\">            </div><div class=\"line\">        &#125;;</div><div class=\"line\">        render() &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> &lt;h1&gt;Wow koa-cola!&lt;/h1&gt;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Index</div></pre></td></tr></table></figure></p>\n<ol>\n<li>stateless组件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;some_props&#125;</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;h1&gt;Wow koa-cola!&lt;/h1&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>react-redux组件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></div><div class=\"line\"><span class=\"keyword\">var</span> Index = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;some_props&#125;</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;h1&gt;Wow koa-cola!&lt;/h1&gt;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</div><div class=\"line\">    mapStateToProps,</div><div class=\"line\">    mapDispatchToProps</div><div class=\"line\">)(Index)</div></pre></td></tr></table></figure>\n<ol>\n<li>redux-connect的decorator<br>使用这种方式的话，需要注意两点：<ul>\n<li>redux的reducer需要使用装饰器colaReducer</li>\n<li>如果有子组件也是使用redux-connect封装，则需要使用装饰器include</li>\n<li>以上两点可以参考todolist的<a href=\"https://github.com/koa-cola/todolist/blob/master/views/pages/colastyleDemo.tsx\" target=\"_blank\" rel=\"external\">代码</a></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> AddTodo <span class=\"keyword\">from</span> <span class=\"string\">'../official-demo/containers/AddTodo'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> FilterLink <span class=\"keyword\">from</span> <span class=\"string\">'../official-demo/containers/FilterLink'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> VisibleTodoList <span class=\"keyword\">from</span> <span class=\"string\">'../official-demo/containers/VisibleTodoList'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">  asyncConnect,</div><div class=\"line\">  colaReducer,</div><div class=\"line\">  include</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'todosData'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\">      <span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div><div class=\"line\">      dispatch(&#123;</div><div class=\"line\">        type: <span class=\"string\">'INIT_TODO'</span>,</div><div class=\"line\">        data: data.result.result</div><div class=\"line\">      &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> data.result.result;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\">@colaReducer(&#123;</div><div class=\"line\">  todos,</div><div class=\"line\">  visibilityFilter</div><div class=\"line\">&#125;)</div><div class=\"line\">@include(&#123; AddTodo, FilterLink, VisibleTodoList &#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColastyleDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;App /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">export default ColastyleDemo;</div></pre></td></tr></table></figure>\n<ol>\n<li>自定义header和bundle方式</li>\n</ol>\n<p>koa-cola渲染页面时，默认会找views/pages/layout.ts封装页面的html，如果没有这个layout文件，则直接输出page组件的html，如果view组件使用了doNotUseLayout decorator，则页面不会使用layout.ts输出，这时你可以自定义header和bundle的decorator。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">  header, bundle, doNotUseLayout</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'../../../dist'</span>).Decorators.view;</div><div class=\"line\">@doNotUseLayout</div><div class=\"line\">@bundle([</div><div class=\"line\">  <span class=\"string\">\"/bundle.js\"</span>,</div><div class=\"line\">  <span class=\"string\">\"/test.js\"</span></div><div class=\"line\">])</div><div class=\"line\">@header(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &lt;head&gt;</div><div class=\"line\">    &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt;</div><div class=\"line\">  &lt;/head&gt;</div><div class=\"line\">&#125;)</div><div class=\"line\">function Page ()&#123;</div><div class=\"line\">  return &lt;h1&gt;koa-cola&lt;/h1&gt;</div><div class=\"line\">&#125;;</div><div class=\"line\">export default Page</div></pre></td></tr></table></figure>\n<h3 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h3><p>和必须使用decorator的controller层、必须使用react组件的view层不一样，model层是完全没有耦合，你可以使用任何你喜欢的orm或者odm，或者不需要model层也可以，不过使用koa-cola风格的来写model，你可以体验不一样的开发模式。</p>\n<ol>\n<li>你可以直接在目录api/models下创建如user.ts：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> mongoose <span class=\"keyword\">from</span> <span class=\"string\">'mongoose'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> mongoose.model(<span class=\"string\">'user'</span>, <span class=\"keyword\">new</span> mongoose.Schema(&#123;</div><div class=\"line\">    name : <span class=\"built_in\">String</span>,</div><div class=\"line\">    email : <span class=\"built_in\">String</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后就可以在其他代码里面使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">await</span> app.models.user.find(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'harry'</span>&#125;)</div></pre></td></tr></table></figure></p>\n<ol>\n<li>使用koa-cola的风格写model</li>\n</ol>\n<p>首先在<code>api/schemas</code>目录创建user.ts</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> userSchema = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mongoose</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        name: &#123;</div><div class=\"line\">            type : <span class=\"built_in\">String</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        email : &#123;</div><div class=\"line\">            type : <span class=\"built_in\">String</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在目录<code>api/models</code>下创建model如user.ts：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> mongoose <span class=\"keyword\">from</span> <span class=\"string\">'mongoose'</span></div><div class=\"line\"><span class=\"keyword\">import</span> userSchema <span class=\"keyword\">from</span> <span class=\"string\">'../schemas/user'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> mongoose.model(<span class=\"string\">'user'</span>, <span class=\"keyword\">new</span> mongoose.Schema(userSchema(mongoose)))</div></pre></td></tr></table></figure></p>\n<p>当然也可以使用decorator方式定义model，还可以定义相关hook，详情可以参考<a href=\"https://github.com/aksyonov/mongoose-decorators\" target=\"_blank\" rel=\"external\">mongoose-decorators</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; todoListSchema &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../schemas/todoList'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123; model &#125; = app.decorators.model;</div><div class=\"line\"></div><div class=\"line\">@model(todoListSchema(app.mongoose))</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TodoList</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>使用cli生成model的schema</p>\n<p><code>koa-cola --schema</code> 自动生成model的接口定义在<code>typings/schema.ts</code></p>\n<p>然后你可以在代码通过使用typescript的类型定义，享受vscode的intellisense带来的乐趣<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;userSchema&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./typings/schema'</span> </div><div class=\"line\"><span class=\"keyword\">var</span> user : userSchema = <span class=\"keyword\">await</span> app.models.user.find(&#123;<span class=\"attr\">name</span> : <span class=\"string\">'harry'</span>&#125;)</div></pre></td></tr></table></figure></p>\n<p>在前面提到的为什么需要在api/schemas定义model的schema，除了上面可以自动生成schema的接口，这部分可以在浏览器端代码复用，比如数据Validate。详细可以查看<a href=\"http://mongoosejs.com/docs/browser.html\" target=\"_blank\" rel=\"external\">文档</a></p>\n<ol>\n<li>koa-cola提供了前后端universal的api接口定义，比如todolist demo的获取数据的接口定义</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; todoListSchema &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./typings/schema'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; ApiBase, apiFetch &#125; <span class=\"keyword\">from</span> <span class=\"string\">'koa-cola'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetTodoList</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApiBase</span>&lt;</span></div><div class=\"line\"><span class=\"class\">  </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 参数类型</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    code: number;</div><div class=\"line\">    result: [todoListSchema];</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">      <span class=\"comment\">// 异常定义</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(body) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(body);</div><div class=\"line\">  &#125;</div><div class=\"line\">  url: string = <span class=\"string\">'/api/getTodoList'</span>;</div><div class=\"line\">  method: string = <span class=\"string\">'get'</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在代码里面使用api，并享受ts带来的乐趣：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api1.png\" alt=\"Drawing\" width=\"600\"><br><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api2.png\" alt=\"Drawing\" width=\"600\"></p>\n<p>又比如参数body的定义，如果定义了必传参数，调用时候没有传，则vscode会提示错误<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; testSchema &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./typings/schema'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; ApiBase, apiFetch &#125; <span class=\"keyword\">from</span> <span class=\"string\">'koa-cola'</span></div><div class=\"line\"><span class=\"keyword\">export</span> interface ComposeBody&#123;</div><div class=\"line\">    foo : string,</div><div class=\"line\">    bar? : number</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compose</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApiBase</span>&lt;<span class=\"title\">ComposeBody</span>, <span class=\"title\">testSchema</span>, </span>&#123;&#125;&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(body : ComposeBody)&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(body)</div><div class=\"line\">    &#125;</div><div class=\"line\">    url : string = <span class=\"string\">'/compose'</span></div><div class=\"line\">    method : string = <span class=\"string\">'post'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/api3.png\" alt=\"Drawing\" width=\"600\"></p>\n"},{"layout":"default","id":"config-env","title":"config/env","prev":"config.html","next":"public.html","_content":"","source":"config-env.md","raw":"---\nlayout: default\nid: config-env\ntitle: config/env\nprev: config.html\nnext: public.html\n---","date":"2017-08-11T03:12:18.998Z","updated":"2017-08-11T03:12:18.998Z","path":"config-env.html","comments":1,"_id":"cj67atjd00008n4ivibm18ydj","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"installation","title":"如何使用","prev":"d-mvc.html","next":"cli.html","_content":"\n\nkoa-cola支持node.js的版本包括7.6和8，建议使用8，因为8.0使用的最新的v8版本，而且8.0会在[今年10月正式激活LTS](https://github.com/nodejs/LTS)，因为koa-cola的async/await是原生方式使用没有经过transform成es6，所以不支持node7.6以下的node版本。\n\n* `npm i koa-cola ts-node -g`\n* `koa-cola new app` 在当前文件夹创建名字为app的新koa-cola项目，创建完整的目录结构，并自动安装依赖\n* `cd app`\n* `koa-cola cheer` 执行webpack build bundle，并启动项目\n* 访问[http://localhost:3000](http://localhost:3000)\n(在开发环境，可以使用`npm run watch`和`npm run local`进行开发)\n\n","source":"installation.md","raw":"---\nlayout: default\nid: installation\ntitle: 如何使用\nprev: d-mvc.html\nnext: cli.html\n---\n\n\nkoa-cola支持node.js的版本包括7.6和8，建议使用8，因为8.0使用的最新的v8版本，而且8.0会在[今年10月正式激活LTS](https://github.com/nodejs/LTS)，因为koa-cola的async/await是原生方式使用没有经过transform成es6，所以不支持node7.6以下的node版本。\n\n* `npm i koa-cola ts-node -g`\n* `koa-cola new app` 在当前文件夹创建名字为app的新koa-cola项目，创建完整的目录结构，并自动安装依赖\n* `cd app`\n* `koa-cola cheer` 执行webpack build bundle，并启动项目\n* 访问[http://localhost:3000](http://localhost:3000)\n(在开发环境，可以使用`npm run watch`和`npm run local`进行开发)\n\n","date":"2017-08-10T10:17:03.693Z","updated":"2017-08-10T10:17:03.693Z","path":"installation.html","comments":1,"_id":"cj67atjd10009n4ivyazry9ai","content":"<p>koa-cola支持node.js的版本包括7.6和8，建议使用8，因为8.0使用的最新的v8版本，而且8.0会在<a href=\"https://github.com/nodejs/LTS\" target=\"_blank\" rel=\"external\">今年10月正式激活LTS</a>，因为koa-cola的async/await是原生方式使用没有经过transform成es6，所以不支持node7.6以下的node版本。</p>\n<ul>\n<li><code>npm i koa-cola ts-node -g</code></li>\n<li><code>koa-cola new app</code> 在当前文件夹创建名字为app的新koa-cola项目，创建完整的目录结构，并自动安装依赖</li>\n<li><code>cd app</code></li>\n<li><code>koa-cola cheer</code> 执行webpack build bundle，并启动项目</li>\n<li>访问<a href=\"http://localhost:3000\" target=\"_blank\" rel=\"external\">http://localhost:3000</a><br>(在开发环境，可以使用<code>npm run watch</code>和<code>npm run local</code>进行开发)</li>\n</ul>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>koa-cola支持node.js的版本包括7.6和8，建议使用8，因为8.0使用的最新的v8版本，而且8.0会在<a href=\"https://github.com/nodejs/LTS\" target=\"_blank\" rel=\"external\">今年10月正式激活LTS</a>，因为koa-cola的async/await是原生方式使用没有经过transform成es6，所以不支持node7.6以下的node版本。</p>\n<ul>\n<li><code>npm i koa-cola ts-node -g</code></li>\n<li><code>koa-cola new app</code> 在当前文件夹创建名字为app的新koa-cola项目，创建完整的目录结构，并自动安装依赖</li>\n<li><code>cd app</code></li>\n<li><code>koa-cola cheer</code> 执行webpack build bundle，并启动项目</li>\n<li>访问<a href=\"http://localhost:3000\" target=\"_blank\" rel=\"external\">http://localhost:3000</a><br>(在开发环境，可以使用<code>npm run watch</code>和<code>npm run local</code>进行开发)</li>\n</ul>\n"},{"layout":"default","id":"index","title":"koa-cola是什么?","next":"ssr.html","_content":"\nkoa-cola是一个基于koa和react的SSR(server side render)web前后端全栈应用框架，使用typescript开发，使用d-mvc（es7 decorator风格的mvc）开发模式。另外koa-cola大量使用universal (\"isomorphic\") 开发模式，比如react技术栈完全前后端universal（server端和client端均可以使用同一套component、react-redux、react-router）。\n\n## 特点\nkoa-cola的开发风格受[sails](http://sailsjs.com/)影响，之前使用过sails开发过大型的web应用，深受其[约定优先配置](https://en.wikipedia.org/wiki/Convention_over_configuration)的开发模式影响。\n* 使用koa作为web服务（使用node8可以使用最新的v8高性能原生使用async/await）\n* 使用typescript开发\n* 使用完整的react技术栈(包括react-router和react-redux)\n* react相关代码前后端复用(包括component渲染、react-router和react-redux)\n* SSR(server side render)的完整方案，只需要一份react代码便可以实现：服务器端渲染＋浏览器端bundle实现的交互","source":"index.md","raw":"---\nlayout: default\nid: index\ntitle: koa-cola是什么?\nnext: ssr.html\n---\n\nkoa-cola是一个基于koa和react的SSR(server side render)web前后端全栈应用框架，使用typescript开发，使用d-mvc（es7 decorator风格的mvc）开发模式。另外koa-cola大量使用universal (\"isomorphic\") 开发模式，比如react技术栈完全前后端universal（server端和client端均可以使用同一套component、react-redux、react-router）。\n\n## 特点\nkoa-cola的开发风格受[sails](http://sailsjs.com/)影响，之前使用过sails开发过大型的web应用，深受其[约定优先配置](https://en.wikipedia.org/wiki/Convention_over_configuration)的开发模式影响。\n* 使用koa作为web服务（使用node8可以使用最新的v8高性能原生使用async/await）\n* 使用typescript开发\n* 使用完整的react技术栈(包括react-router和react-redux)\n* react相关代码前后端复用(包括component渲染、react-router和react-redux)\n* SSR(server side render)的完整方案，只需要一份react代码便可以实现：服务器端渲染＋浏览器端bundle实现的交互","date":"2017-08-07T08:06:17.020Z","updated":"2017-08-07T08:06:17.020Z","path":"index.html","comments":1,"_id":"cj67atjd1000an4ivxerui4x5","content":"<p>koa-cola是一个基于koa和react的SSR(server side render)web前后端全栈应用框架，使用typescript开发，使用d-mvc（es7 decorator风格的mvc）开发模式。另外koa-cola大量使用universal (“isomorphic”) 开发模式，比如react技术栈完全前后端universal（server端和client端均可以使用同一套component、react-redux、react-router）。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>koa-cola的开发风格受<a href=\"http://sailsjs.com/\" target=\"_blank\" rel=\"external\">sails</a>影响，之前使用过sails开发过大型的web应用，深受其<a href=\"https://en.wikipedia.org/wiki/Convention_over_configuration\" target=\"_blank\" rel=\"external\">约定优先配置</a>的开发模式影响。</p>\n<ul>\n<li>使用koa作为web服务（使用node8可以使用最新的v8高性能原生使用async/await）</li>\n<li>使用typescript开发</li>\n<li>使用完整的react技术栈(包括react-router和react-redux)</li>\n<li>react相关代码前后端复用(包括component渲染、react-router和react-redux)</li>\n<li>SSR(server side render)的完整方案，只需要一份react代码便可以实现：服务器端渲染＋浏览器端bundle实现的交互</li>\n</ul>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>koa-cola是一个基于koa和react的SSR(server side render)web前后端全栈应用框架，使用typescript开发，使用d-mvc（es7 decorator风格的mvc）开发模式。另外koa-cola大量使用universal (“isomorphic”) 开发模式，比如react技术栈完全前后端universal（server端和client端均可以使用同一套component、react-redux、react-router）。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>koa-cola的开发风格受<a href=\"http://sailsjs.com/\" target=\"_blank\" rel=\"external\">sails</a>影响，之前使用过sails开发过大型的web应用，深受其<a href=\"https://en.wikipedia.org/wiki/Convention_over_configuration\" target=\"_blank\" rel=\"external\">约定优先配置</a>的开发模式影响。</p>\n<ul>\n<li>使用koa作为web服务（使用node8可以使用最新的v8高性能原生使用async/await）</li>\n<li>使用typescript开发</li>\n<li>使用完整的react技术栈(包括react-router和react-redux)</li>\n<li>react相关代码前后端复用(包括component渲染、react-router和react-redux)</li>\n<li>SSR(server side render)的完整方案，只需要一份react代码便可以实现：服务器端渲染＋浏览器端bundle实现的交互</li>\n</ul>\n"},{"layout":"default","id":"public","title":"public","prev":"config-env.html","next":"views.html","_content":"","source":"public.md","raw":"---\nlayout: default\nid: public\ntitle: public\nprev: config-env.html\nnext: views.html\n---","date":"2017-08-11T03:12:34.827Z","updated":"2017-08-11T03:12:34.827Z","path":"public.html","comments":1,"_id":"cj67atjd2000bn4ivu98fgv01","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"tip1-react-init","title":"初始化react组件数据","next":"tip2-redux.html","_content":"\nkoa-cola提供两种方式初始化react。\n\n1. 在controller里面初始化\n\n初始化数据，数据将会注入到react组件的props.ctrl，如：this.props.ctrl.foo\n\n```javascript\nvar { Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response } = require('koa-cola').Decorators.controller;\n@Controller('') \nclass FooController {\n    @Get('/some_page')  \n    @View('some_page') // some_page是普通react组件\n    async some_page (@Ctx() ctx, @QueryParam() param : any) { \n        // 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo\n        return await Promise.resolve({\n            foo : 'bar'\n        });\n    }\n}\n```  \n\n2. 在redux-connect封装的react组件初始化数据\n\n\n```javascript\nvar {asyncConnect} = require('koa-cola').Decorators.view;\n@asyncConnect([\n  {\n    key: 'foo',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n        return await Promise.resolve({\n            foo : 'bar'\n        });\n    }\n  }\n])\nclass Some_Page extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>{this.props.foo}</div>;\n  }\n}\nexport default Some_Page;\n```\n\n这两种方式的区别是：\n\n第一种方式：\n* 只会在服务器端进行初始化\n* 只支持非react-redux或者redux-connect封装的组件\n* 因为只会在服务器端进行初始化，所以可以支持任何获取数据的方式比如数据库获取\n\n第二种方式：\n* 服务器端和浏览器端都支持（服务器端就是SSR，浏览器端就是异步获取数据）\n* redux-connect封装的组件\n* 因为服务器端和浏览器端都支持初始化，所以数据的获取必须前后端Universal，比如使用axios库","source":"tip1-react-init.md","raw":"---\nlayout: default\nid: tip1-react-init\ntitle: 初始化react组件数据\nnext: tip2-redux.html\n---\n\nkoa-cola提供两种方式初始化react。\n\n1. 在controller里面初始化\n\n初始化数据，数据将会注入到react组件的props.ctrl，如：this.props.ctrl.foo\n\n```javascript\nvar { Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response } = require('koa-cola').Decorators.controller;\n@Controller('') \nclass FooController {\n    @Get('/some_page')  \n    @View('some_page') // some_page是普通react组件\n    async some_page (@Ctx() ctx, @QueryParam() param : any) { \n        // 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo\n        return await Promise.resolve({\n            foo : 'bar'\n        });\n    }\n}\n```  \n\n2. 在redux-connect封装的react组件初始化数据\n\n\n```javascript\nvar {asyncConnect} = require('koa-cola').Decorators.view;\n@asyncConnect([\n  {\n    key: 'foo',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n        return await Promise.resolve({\n            foo : 'bar'\n        });\n    }\n  }\n])\nclass Some_Page extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>{this.props.foo}</div>;\n  }\n}\nexport default Some_Page;\n```\n\n这两种方式的区别是：\n\n第一种方式：\n* 只会在服务器端进行初始化\n* 只支持非react-redux或者redux-connect封装的组件\n* 因为只会在服务器端进行初始化，所以可以支持任何获取数据的方式比如数据库获取\n\n第二种方式：\n* 服务器端和浏览器端都支持（服务器端就是SSR，浏览器端就是异步获取数据）\n* redux-connect封装的组件\n* 因为服务器端和浏览器端都支持初始化，所以数据的获取必须前后端Universal，比如使用axios库","date":"2017-08-11T03:02:54.044Z","updated":"2017-08-11T03:02:54.044Z","path":"tip1-react-init.html","comments":1,"_id":"cj67atjd2000cn4ivya32fb8w","content":"<p>koa-cola提供两种方式初始化react。</p>\n<ol>\n<li>在controller里面初始化</li>\n</ol>\n<p>初始化数据，数据将会注入到react组件的props.ctrl，如：this.props.ctrl.foo</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.controller;</div><div class=\"line\">@Controller(<span class=\"string\">''</span>) </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span> </span>&#123;</div><div class=\"line\">    @Get(<span class=\"string\">'/some_page'</span>)  </div><div class=\"line\">    @View(<span class=\"string\">'some_page'</span>) <span class=\"comment\">// some_page是普通react组件</span></div><div class=\"line\">    <span class=\"keyword\">async</span> some_page (@Ctx() ctx, @QueryParam() param : any) &#123; </div><div class=\"line\">        <span class=\"comment\">// 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(&#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">2. 在redux-connect封装的react组件初始化数据</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;asyncConnect&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'foo'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(&#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some_Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;&#123;this.props.foo&#125;&lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Some_Page;</div></pre></td></tr></table></figure>\n<p>这两种方式的区别是：</p>\n<p>第一种方式：</p>\n<ul>\n<li>只会在服务器端进行初始化</li>\n<li>只支持非react-redux或者redux-connect封装的组件</li>\n<li>因为只会在服务器端进行初始化，所以可以支持任何获取数据的方式比如数据库获取</li>\n</ul>\n<p>第二种方式：</p>\n<ul>\n<li>服务器端和浏览器端都支持（服务器端就是SSR，浏览器端就是异步获取数据）</li>\n<li>redux-connect封装的组件</li>\n<li>因为服务器端和浏览器端都支持初始化，所以数据的获取必须前后端Universal，比如使用axios库</li>\n</ul>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>koa-cola提供两种方式初始化react。</p>\n<ol>\n<li>在controller里面初始化</li>\n</ol>\n<p>初始化数据，数据将会注入到react组件的props.ctrl，如：this.props.ctrl.foo</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; Controller, Get, Use, Param, Body, Delete, Put, Post, QueryParam, View, Ctx, Response &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.controller;</div><div class=\"line\">@Controller(<span class=\"string\">''</span>) </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span> </span>&#123;</div><div class=\"line\">    @Get(<span class=\"string\">'/some_page'</span>)  </div><div class=\"line\">    @View(<span class=\"string\">'some_page'</span>) <span class=\"comment\">// some_page是普通react组件</span></div><div class=\"line\">    <span class=\"keyword\">async</span> some_page (@Ctx() ctx, @QueryParam() param : any) &#123; </div><div class=\"line\">        <span class=\"comment\">// 初始化数据，数据将会注入到react组件的props，如：this.props.ctrl.foo</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(&#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">2. 在redux-connect封装的react组件初始化数据</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;asyncConnect&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'foo'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(&#123;</div><div class=\"line\">            foo : <span class=\"string\">'bar'</span></div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some_Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;&#123;this.props.foo&#125;&lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Some_Page;</div></pre></td></tr></table></figure>\n<p>这两种方式的区别是：</p>\n<p>第一种方式：</p>\n<ul>\n<li>只会在服务器端进行初始化</li>\n<li>只支持非react-redux或者redux-connect封装的组件</li>\n<li>因为只会在服务器端进行初始化，所以可以支持任何获取数据的方式比如数据库获取</li>\n</ul>\n<p>第二种方式：</p>\n<ul>\n<li>服务器端和浏览器端都支持（服务器端就是SSR，浏览器端就是异步获取数据）</li>\n<li>redux-connect封装的组件</li>\n<li>因为服务器端和浏览器端都支持初始化，所以数据的获取必须前后端Universal，比如使用axios库</li>\n</ul>\n"},{"layout":"default","id":"ssr","title":"SSR和SPA","prev":"index.html","next":"compare-next.html","_content":"\nkoa-cola是一个包括前后端全栈的框架，在服务器端，支持以react作为组件模板的方式直接渲染到浏览器端的SSR（Server Side Render）的架构，在浏览器端，支持react-router的bundle的SPA(Single Page Application）架构，SSR和SPA各有优缺点，SPA通过浏览器端router控制页面的跳转，交互体验更友好，但是对于搜索引擎不友好，所以支持SSR是无可避免的，对于开发者，开发koa-cola应用，不需要在写代码时候关心这段代码到底是SSR直渲还是SPA的异步，你只需要关心业务逻辑，koa-cola会帮助你解决代码在不同的环境运行。\n\n```javascript\n@asyncConnect([\n  {\n    key: 'some_data',\n    promise: async ({ params, helpers}) => {\n      return await fetch('/some/data/api');\n    }\n  }\n])\nclass Index extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>\n        {this.props.some_data}\n    </div>;\n  }\n}\nexport default Index;\n```\n 上面这段是koa-cola项目里面使用了asyncConnect的装饰器来初始化数据。\n \n * 当刷新页面，需要SSR方式直渲Index页面时，服务器端会通过fetch获取数据，然后再渲染出来html。\n * 当在其他页面点击了<link>的react组件时，浏览器端则会通过router找到这个组件，然后在浏览器端使用fetch方法异步获取数据，然后重新在浏览器端渲染页面，这就是SPA方式。\n\n fetch是一个前后端均可支持的“universal”库，在koa-cola，开发者不但可以前后端使用数据请求接口fetch，甚至可以前后端使用router和redux，和部分组件(在服务器端react组件只支持render之前的生命周期)。\n","source":"ssr.md","raw":"---\nlayout: default\nid: ssr\ntitle: SSR和SPA\nprev: index.html\nnext: compare-next.html\n---\n\nkoa-cola是一个包括前后端全栈的框架，在服务器端，支持以react作为组件模板的方式直接渲染到浏览器端的SSR（Server Side Render）的架构，在浏览器端，支持react-router的bundle的SPA(Single Page Application）架构，SSR和SPA各有优缺点，SPA通过浏览器端router控制页面的跳转，交互体验更友好，但是对于搜索引擎不友好，所以支持SSR是无可避免的，对于开发者，开发koa-cola应用，不需要在写代码时候关心这段代码到底是SSR直渲还是SPA的异步，你只需要关心业务逻辑，koa-cola会帮助你解决代码在不同的环境运行。\n\n```javascript\n@asyncConnect([\n  {\n    key: 'some_data',\n    promise: async ({ params, helpers}) => {\n      return await fetch('/some/data/api');\n    }\n  }\n])\nclass Index extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>\n        {this.props.some_data}\n    </div>;\n  }\n}\nexport default Index;\n```\n 上面这段是koa-cola项目里面使用了asyncConnect的装饰器来初始化数据。\n \n * 当刷新页面，需要SSR方式直渲Index页面时，服务器端会通过fetch获取数据，然后再渲染出来html。\n * 当在其他页面点击了<link>的react组件时，浏览器端则会通过router找到这个组件，然后在浏览器端使用fetch方法异步获取数据，然后重新在浏览器端渲染页面，这就是SPA方式。\n\n fetch是一个前后端均可支持的“universal”库，在koa-cola，开发者不但可以前后端使用数据请求接口fetch，甚至可以前后端使用router和redux，和部分组件(在服务器端react组件只支持render之前的生命周期)。\n","date":"2017-08-07T09:50:13.501Z","updated":"2017-08-07T09:50:13.501Z","path":"ssr.html","comments":1,"_id":"cj67atjd3000dn4ivci5if34d","content":"<p>koa-cola是一个包括前后端全栈的框架，在服务器端，支持以react作为组件模板的方式直接渲染到浏览器端的SSR（Server Side Render）的架构，在浏览器端，支持react-router的bundle的SPA(Single Page Application）架构，SSR和SPA各有优缺点，SPA通过浏览器端router控制页面的跳转，交互体验更友好，但是对于搜索引擎不友好，所以支持SSR是无可避免的，对于开发者，开发koa-cola应用，不需要在写代码时候关心这段代码到底是SSR直渲还是SPA的异步，你只需要关心业务逻辑，koa-cola会帮助你解决代码在不同的环境运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'some_data'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers&#125;) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> fetch(<span class=\"string\">'/some/data/api'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">        &#123;this.props.some_data&#125;</div><div class=\"line\">    &lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Index;</div></pre></td></tr></table></figure>\n<p> 上面这段是koa-cola项目里面使用了asyncConnect的装饰器来初始化数据。</p>\n<ul>\n<li>当刷新页面，需要SSR方式直渲Index页面时，服务器端会通过fetch获取数据，然后再渲染出来html。</li>\n<li><p>当在其他页面点击了<link>的react组件时，浏览器端则会通过router找到这个组件，然后在浏览器端使用fetch方法异步获取数据，然后重新在浏览器端渲染页面，这就是SPA方式。</p>\n<p>fetch是一个前后端均可支持的“universal”库，在koa-cola，开发者不但可以前后端使用数据请求接口fetch，甚至可以前后端使用router和redux，和部分组件(在服务器端react组件只支持render之前的生命周期)。</p>\n</li>\n</ul>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>koa-cola是一个包括前后端全栈的框架，在服务器端，支持以react作为组件模板的方式直接渲染到浏览器端的SSR（Server Side Render）的架构，在浏览器端，支持react-router的bundle的SPA(Single Page Application）架构，SSR和SPA各有优缺点，SPA通过浏览器端router控制页面的跳转，交互体验更友好，但是对于搜索引擎不友好，所以支持SSR是无可避免的，对于开发者，开发koa-cola应用，不需要在写代码时候关心这段代码到底是SSR直渲还是SPA的异步，你只需要关心业务逻辑，koa-cola会帮助你解决代码在不同的环境运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'some_data'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers&#125;) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> fetch(<span class=\"string\">'/some/data/api'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">        &#123;this.props.some_data&#125;</div><div class=\"line\">    &lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Index;</div></pre></td></tr></table></figure>\n<p> 上面这段是koa-cola项目里面使用了asyncConnect的装饰器来初始化数据。</p>\n<ul>\n<li>当刷新页面，需要SSR方式直渲Index页面时，服务器端会通过fetch获取数据，然后再渲染出来html。</li>\n<li><p>当在其他页面点击了<link>的react组件时，浏览器端则会通过router找到这个组件，然后在浏览器端使用fetch方法异步获取数据，然后重新在浏览器端渲染页面，这就是SPA方式。</p>\n<p>fetch是一个前后端均可支持的“universal”库，在koa-cola，开发者不但可以前后端使用数据请求接口fetch，甚至可以前后端使用router和redux，和部分组件(在服务器端react组件只支持render之前的生命周期)。</p>\n</li>\n</ul>\n"},{"layout":"default","id":"tip3-inject-global","title":"Inject global全局注入","prev":"tip2-redux.html","next":"tip4-cluster.html","_content":"\n全局依赖注入，有时候在其他非应用运行时引用koa-cola里面的文件时，会因为文件依赖`app.xxx`而出错，使用inject global方式，可以实现第三方非koa-cola的require。\n```javascript\nimport { reqInject } from 'koa-cola'\nvar user;\nreqInject(function(){\n    user = require('./api/models/user').default // 直接require项目内的文件\n    var config = app.config; // 或者app当前配置\n});\n```","source":"tip3-inject-global.md","raw":"---\nlayout: default\nid: tip3-inject-global\ntitle: Inject global全局注入\nprev: tip2-redux.html\nnext: tip4-cluster.html\n---\n\n全局依赖注入，有时候在其他非应用运行时引用koa-cola里面的文件时，会因为文件依赖`app.xxx`而出错，使用inject global方式，可以实现第三方非koa-cola的require。\n```javascript\nimport { reqInject } from 'koa-cola'\nvar user;\nreqInject(function(){\n    user = require('./api/models/user').default // 直接require项目内的文件\n    var config = app.config; // 或者app当前配置\n});\n```","date":"2017-08-11T03:04:49.853Z","updated":"2017-08-11T03:04:49.853Z","path":"tip3-inject-global.html","comments":1,"_id":"cj67atjd3000en4ivjxtc76ru","content":"<p>全局依赖注入，有时候在其他非应用运行时引用koa-cola里面的文件时，会因为文件依赖<code>app.xxx</code>而出错，使用inject global方式，可以实现第三方非koa-cola的require。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; reqInject &#125; <span class=\"keyword\">from</span> <span class=\"string\">'koa-cola'</span></div><div class=\"line\"><span class=\"keyword\">var</span> user;</div><div class=\"line\">reqInject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    user = <span class=\"built_in\">require</span>(<span class=\"string\">'./api/models/user'</span>).default <span class=\"comment\">// 直接require项目内的文件</span></div><div class=\"line\">    <span class=\"keyword\">var</span> config = app.config; <span class=\"comment\">// 或者app当前配置</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>全局依赖注入，有时候在其他非应用运行时引用koa-cola里面的文件时，会因为文件依赖<code>app.xxx</code>而出错，使用inject global方式，可以实现第三方非koa-cola的require。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; reqInject &#125; <span class=\"keyword\">from</span> <span class=\"string\">'koa-cola'</span></div><div class=\"line\"><span class=\"keyword\">var</span> user;</div><div class=\"line\">reqInject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    user = <span class=\"built_in\">require</span>(<span class=\"string\">'./api/models/user'</span>).default <span class=\"comment\">// 直接require项目内的文件</span></div><div class=\"line\">    <span class=\"keyword\">var</span> config = app.config; <span class=\"comment\">// 或者app当前配置</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n"},{"layout":"default","id":"tip4-cluster","title":"cluster集群模式","prev":"tip3-inject-global.html","next":"tip5-debug.html","_content":"\n如果你想使用cluster模式，koa-cola提供了pm2的配置文件，使用cli新建项目时候会生成这个配置文件，启动方式使用：`pm2 start pm2.config.js`","source":"tip4-cluster.md","raw":"---\nlayout: default\nid: tip4-cluster\ntitle: cluster集群模式\nprev: tip3-inject-global.html\nnext: tip5-debug.html\n---\n\n如果你想使用cluster模式，koa-cola提供了pm2的配置文件，使用cli新建项目时候会生成这个配置文件，启动方式使用：`pm2 start pm2.config.js`","date":"2017-08-11T03:07:58.953Z","updated":"2017-08-11T03:07:58.953Z","path":"tip4-cluster.html","comments":1,"_id":"cj67atjd3000fn4iv910k9r5m","content":"<p>如果你想使用cluster模式，koa-cola提供了pm2的配置文件，使用cli新建项目时候会生成这个配置文件，启动方式使用：<code>pm2 start pm2.config.js</code></p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>如果你想使用cluster模式，koa-cola提供了pm2的配置文件，使用cli新建项目时候会生成这个配置文件，启动方式使用：<code>pm2 start pm2.config.js</code></p>\n"},{"layout":"default","id":"tip5-debug","title":"调试","prev":"tip4-cluster.html","next":"tip6-compile.html","_content":"\n如果需要调试koa-cola项目，需要添加两个依赖`npm i ts-node typescript -S`，然后在vscode新建调试配置：\n\n```json\n{\n    \"name\": \"DebugApp\",\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"program\": \"${workspaceRoot}/node_modules/ts-node/dist/_bin.js\",\n    \"stopOnEntry\": false,\n    \"args\": [],\n    \"runtimeArgs\": [\n        \"-r\", \"ts-node/register\",\n        \"${workspaceRoot}/app.tsx\"\n    ],\n    \"sourceMaps\": true,\n    \"console\": \"internalConsole\",\n    \"internalConsoleOptions\": \"openOnSessionStart\"\n}\n```\n便可享受vscode的调试ts的乐趣。\n\n另外，koa-cola加了redux调试支持，你也可以使用chrome的redux插件调试：\n\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/dev-tool.png\" alt=\"Drawing\" width=\"600\"/>","source":"tip5-debug.md","raw":"---\nlayout: default\nid: tip5-debug\ntitle: 调试\nprev: tip4-cluster.html\nnext: tip6-compile.html\n---\n\n如果需要调试koa-cola项目，需要添加两个依赖`npm i ts-node typescript -S`，然后在vscode新建调试配置：\n\n```json\n{\n    \"name\": \"DebugApp\",\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"program\": \"${workspaceRoot}/node_modules/ts-node/dist/_bin.js\",\n    \"stopOnEntry\": false,\n    \"args\": [],\n    \"runtimeArgs\": [\n        \"-r\", \"ts-node/register\",\n        \"${workspaceRoot}/app.tsx\"\n    ],\n    \"sourceMaps\": true,\n    \"console\": \"internalConsole\",\n    \"internalConsoleOptions\": \"openOnSessionStart\"\n}\n```\n便可享受vscode的调试ts的乐趣。\n\n另外，koa-cola加了redux调试支持，你也可以使用chrome的redux插件调试：\n\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/dev-tool.png\" alt=\"Drawing\" width=\"600\"/>","date":"2017-08-11T03:08:02.421Z","updated":"2017-08-11T03:08:02.421Z","path":"tip5-debug.html","comments":1,"_id":"cj67atjd4000gn4iv7y8x5ik5","content":"<p>如果需要调试koa-cola项目，需要添加两个依赖<code>npm i ts-node typescript -S</code>，然后在vscode新建调试配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"DebugApp\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"node\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;workspaceRoot&#125;/node_modules/ts-node/dist/_bin.js\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"stopOnEntry\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">\"args\"</span>: [],</div><div class=\"line\">    <span class=\"attr\">\"runtimeArgs\"</span>: [</div><div class=\"line\">        <span class=\"string\">\"-r\"</span>, <span class=\"string\">\"ts-node/register\"</span>,</div><div class=\"line\">        <span class=\"string\">\"$&#123;workspaceRoot&#125;/app.tsx\"</span></div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"attr\">\"sourceMaps\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">\"console\"</span>: <span class=\"string\">\"internalConsole\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"internalConsoleOptions\"</span>: <span class=\"string\">\"openOnSessionStart\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>便可享受vscode的调试ts的乐趣。</p>\n<p>另外，koa-cola加了redux调试支持，你也可以使用chrome的redux插件调试：</p>\n<p><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/dev-tool.png\" alt=\"Drawing\" width=\"600\"></p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>如果需要调试koa-cola项目，需要添加两个依赖<code>npm i ts-node typescript -S</code>，然后在vscode新建调试配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"DebugApp\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"node\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;workspaceRoot&#125;/node_modules/ts-node/dist/_bin.js\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"stopOnEntry\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">\"args\"</span>: [],</div><div class=\"line\">    <span class=\"attr\">\"runtimeArgs\"</span>: [</div><div class=\"line\">        <span class=\"string\">\"-r\"</span>, <span class=\"string\">\"ts-node/register\"</span>,</div><div class=\"line\">        <span class=\"string\">\"$&#123;workspaceRoot&#125;/app.tsx\"</span></div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"attr\">\"sourceMaps\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">\"console\"</span>: <span class=\"string\">\"internalConsole\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"internalConsoleOptions\"</span>: <span class=\"string\">\"openOnSessionStart\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>便可享受vscode的调试ts的乐趣。</p>\n<p>另外，koa-cola加了redux调试支持，你也可以使用chrome的redux插件调试：</p>\n<p><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/dev-tool.png\" alt=\"Drawing\" width=\"600\"></p>\n"},{"layout":"default","id":"tip6-compile","title":"代码编译","prev":"tip5-debug.html","_content":"\n\n### client\n前端的bundle build使用webpack来构建，使用cli命令创建项目，会自动生成[webpack配置](https://github.com/hcnode/koa-cola/blob/master/template/webpack.config.js)\nts文件的loader使用了[awesome-typescript-loader](https://github.com/s-panferov/awesome-typescript-loader)，并配置了使用babel，加入babel-polyfill到bundle，可以兼容ie9+。\n\nwebpack的入口tsx文件在项目里面的`view/app.tsx`:\n```javascript\nimport * as React from 'react';\nimport { render } from 'react-dom';\nimport IndexController from '../api/controllers/IndexController';\nimport index from './pages/index';\nimport officialDemo from './pages/officialDemo';\nimport colastyleDemo from './pages/colastyleDemo';\n\nvar { createProvider } = require('koa-cola');\n// 使用koa-cola提供的createProvider会自动建立路由，如果手动使用官方的Provider，则需要开发者手动写router\nvar Provider = createProvider([IndexController], {\n  index,\n  officialDemo,\n  colastyleDemo\n});\n\nrender(<Provider />, document.getElementById('app'));\n```\n\nwepack build 新建默认的项目得到的bundle的大小有400K，依赖的库组成如下图：\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/bundle.png\" alt=\"Drawing\" width=\"800\"/>\n\nwebpack的配置文件默认加了四个IgnorePlugin插件，因为有些文件是前后端都会使用，所以需要忽略服务器端的require。\n\n```javascript\n// 以下两个是给服务器端使用，不能打包到webpack\nnew webpack.IgnorePlugin(/\\.\\/src\\/app/),\nnew webpack.IgnorePlugin(/\\.\\/src\\/util\\/injectGlobal/),\n// 以下两个是controller引用的，也是服务器端使用，也不能打包到webpack，如果你的controller也有服务器端使用的库，也必须要加IgnorePlugin插件\nnew webpack.IgnorePlugin(/koa$/),\nnew webpack.IgnorePlugin(/koa-body$/),\n```\n\n\n### server\nkoa-cola本身框架只编译了部分代码，比如es6的module import和export，ts类型相关的语法，对es6或者es7（比如async/await）没有进行编译，尽量用到node.js原生的es高级语法（所以会不支持低版本的node），如果你想希望你的应用在低版本node下使用，则需要你手动build出你所希望的代码，并包括所依赖的koa-cola库。\n\n如果在node.js 8.0的环境下运行，则可以不需要任何编译，可以直接使用ts-node运行（cli运行命令都是使用ts-node），甚至可以直接[线上使用](https://github.com/TypeStrong/ts-node/issues/104)\n","source":"tip6-compile.md","raw":"---\nlayout: default\nid: tip6-compile\ntitle: 代码编译\nprev: tip5-debug.html\n---\n\n\n### client\n前端的bundle build使用webpack来构建，使用cli命令创建项目，会自动生成[webpack配置](https://github.com/hcnode/koa-cola/blob/master/template/webpack.config.js)\nts文件的loader使用了[awesome-typescript-loader](https://github.com/s-panferov/awesome-typescript-loader)，并配置了使用babel，加入babel-polyfill到bundle，可以兼容ie9+。\n\nwebpack的入口tsx文件在项目里面的`view/app.tsx`:\n```javascript\nimport * as React from 'react';\nimport { render } from 'react-dom';\nimport IndexController from '../api/controllers/IndexController';\nimport index from './pages/index';\nimport officialDemo from './pages/officialDemo';\nimport colastyleDemo from './pages/colastyleDemo';\n\nvar { createProvider } = require('koa-cola');\n// 使用koa-cola提供的createProvider会自动建立路由，如果手动使用官方的Provider，则需要开发者手动写router\nvar Provider = createProvider([IndexController], {\n  index,\n  officialDemo,\n  colastyleDemo\n});\n\nrender(<Provider />, document.getElementById('app'));\n```\n\nwepack build 新建默认的项目得到的bundle的大小有400K，依赖的库组成如下图：\n<img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/bundle.png\" alt=\"Drawing\" width=\"800\"/>\n\nwebpack的配置文件默认加了四个IgnorePlugin插件，因为有些文件是前后端都会使用，所以需要忽略服务器端的require。\n\n```javascript\n// 以下两个是给服务器端使用，不能打包到webpack\nnew webpack.IgnorePlugin(/\\.\\/src\\/app/),\nnew webpack.IgnorePlugin(/\\.\\/src\\/util\\/injectGlobal/),\n// 以下两个是controller引用的，也是服务器端使用，也不能打包到webpack，如果你的controller也有服务器端使用的库，也必须要加IgnorePlugin插件\nnew webpack.IgnorePlugin(/koa$/),\nnew webpack.IgnorePlugin(/koa-body$/),\n```\n\n\n### server\nkoa-cola本身框架只编译了部分代码，比如es6的module import和export，ts类型相关的语法，对es6或者es7（比如async/await）没有进行编译，尽量用到node.js原生的es高级语法（所以会不支持低版本的node），如果你想希望你的应用在低版本node下使用，则需要你手动build出你所希望的代码，并包括所依赖的koa-cola库。\n\n如果在node.js 8.0的环境下运行，则可以不需要任何编译，可以直接使用ts-node运行（cli运行命令都是使用ts-node），甚至可以直接[线上使用](https://github.com/TypeStrong/ts-node/issues/104)\n","date":"2017-08-11T03:08:04.653Z","updated":"2017-08-11T03:08:04.653Z","path":"tip6-compile.html","comments":1,"_id":"cj67atjd5000hn4iva7gpf84i","content":"<h3 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h3><p>前端的bundle build使用webpack来构建，使用cli命令创建项目，会自动生成<a href=\"https://github.com/hcnode/koa-cola/blob/master/template/webpack.config.js\" target=\"_blank\" rel=\"external\">webpack配置</a><br>ts文件的loader使用了<a href=\"https://github.com/s-panferov/awesome-typescript-loader\" target=\"_blank\" rel=\"external\">awesome-typescript-loader</a>，并配置了使用babel，加入babel-polyfill到bundle，可以兼容ie9+。</p>\n<p>webpack的入口tsx文件在项目里面的<code>view/app.tsx</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> IndexController <span class=\"keyword\">from</span> <span class=\"string\">'../api/controllers/IndexController'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> index <span class=\"keyword\">from</span> <span class=\"string\">'./pages/index'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> officialDemo <span class=\"keyword\">from</span> <span class=\"string\">'./pages/officialDemo'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> colastyleDemo <span class=\"keyword\">from</span> <span class=\"string\">'./pages/colastyleDemo'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; createProvider &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>);</div><div class=\"line\"><span class=\"comment\">// 使用koa-cola提供的createProvider会自动建立路由，如果手动使用官方的Provider，则需要开发者手动写router</span></div><div class=\"line\"><span class=\"keyword\">var</span> Provider = createProvider([IndexController], &#123;</div><div class=\"line\">  index,</div><div class=\"line\">  officialDemo,</div><div class=\"line\">  colastyleDemo</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">render(&lt;Provider /&gt;, document.getElementById('app'));</div></pre></td></tr></table></figure></p>\n<p>wepack build 新建默认的项目得到的bundle的大小有400K，依赖的库组成如下图：<br><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/bundle.png\" alt=\"Drawing\" width=\"800\"></p>\n<p>webpack的配置文件默认加了四个IgnorePlugin插件，因为有些文件是前后端都会使用，所以需要忽略服务器端的require。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 以下两个是给服务器端使用，不能打包到webpack</span></div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/\\.\\/src\\/app/</span>),</div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/\\.\\/src\\/util\\/injectGlobal/</span>),</div><div class=\"line\"><span class=\"comment\">// 以下两个是controller引用的，也是服务器端使用，也不能打包到webpack，如果你的controller也有服务器端使用的库，也必须要加IgnorePlugin插件</span></div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/koa$/</span>),</div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/koa-body$/</span>),</div></pre></td></tr></table></figure>\n<h3 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h3><p>koa-cola本身框架只编译了部分代码，比如es6的module import和export，ts类型相关的语法，对es6或者es7（比如async/await）没有进行编译，尽量用到node.js原生的es高级语法（所以会不支持低版本的node），如果你想希望你的应用在低版本node下使用，则需要你手动build出你所希望的代码，并包括所依赖的koa-cola库。</p>\n<p>如果在node.js 8.0的环境下运行，则可以不需要任何编译，可以直接使用ts-node运行（cli运行命令都是使用ts-node），甚至可以直接<a href=\"https://github.com/TypeStrong/ts-node/issues/104\" target=\"_blank\" rel=\"external\">线上使用</a></p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<h3 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h3><p>前端的bundle build使用webpack来构建，使用cli命令创建项目，会自动生成<a href=\"https://github.com/hcnode/koa-cola/blob/master/template/webpack.config.js\" target=\"_blank\" rel=\"external\">webpack配置</a><br>ts文件的loader使用了<a href=\"https://github.com/s-panferov/awesome-typescript-loader\" target=\"_blank\" rel=\"external\">awesome-typescript-loader</a>，并配置了使用babel，加入babel-polyfill到bundle，可以兼容ie9+。</p>\n<p>webpack的入口tsx文件在项目里面的<code>view/app.tsx</code>:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> IndexController <span class=\"keyword\">from</span> <span class=\"string\">'../api/controllers/IndexController'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> index <span class=\"keyword\">from</span> <span class=\"string\">'./pages/index'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> officialDemo <span class=\"keyword\">from</span> <span class=\"string\">'./pages/officialDemo'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> colastyleDemo <span class=\"keyword\">from</span> <span class=\"string\">'./pages/colastyleDemo'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; createProvider &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>);</div><div class=\"line\"><span class=\"comment\">// 使用koa-cola提供的createProvider会自动建立路由，如果手动使用官方的Provider，则需要开发者手动写router</span></div><div class=\"line\"><span class=\"keyword\">var</span> Provider = createProvider([IndexController], &#123;</div><div class=\"line\">  index,</div><div class=\"line\">  officialDemo,</div><div class=\"line\">  colastyleDemo</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">render(&lt;Provider /&gt;, document.getElementById('app'));</div></pre></td></tr></table></figure></p>\n<p>wepack build 新建默认的项目得到的bundle的大小有400K，依赖的库组成如下图：<br><img src=\"https://github.com/hcnode/koa-cola/raw/master/screenshots/bundle.png\" alt=\"Drawing\" width=\"800\"></p>\n<p>webpack的配置文件默认加了四个IgnorePlugin插件，因为有些文件是前后端都会使用，所以需要忽略服务器端的require。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 以下两个是给服务器端使用，不能打包到webpack</span></div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/\\.\\/src\\/app/</span>),</div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/\\.\\/src\\/util\\/injectGlobal/</span>),</div><div class=\"line\"><span class=\"comment\">// 以下两个是controller引用的，也是服务器端使用，也不能打包到webpack，如果你的controller也有服务器端使用的库，也必须要加IgnorePlugin插件</span></div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/koa$/</span>),</div><div class=\"line\"><span class=\"keyword\">new</span> webpack.IgnorePlugin(<span class=\"regexp\">/koa-body$/</span>),</div></pre></td></tr></table></figure>\n<h3 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h3><p>koa-cola本身框架只编译了部分代码，比如es6的module import和export，ts类型相关的语法，对es6或者es7（比如async/await）没有进行编译，尽量用到node.js原生的es高级语法（所以会不支持低版本的node），如果你想希望你的应用在低版本node下使用，则需要你手动build出你所希望的代码，并包括所依赖的koa-cola库。</p>\n<p>如果在node.js 8.0的环境下运行，则可以不需要任何编译，可以直接使用ts-node运行（cli运行命令都是使用ts-node），甚至可以直接<a href=\"https://github.com/TypeStrong/ts-node/issues/104\" target=\"_blank\" rel=\"external\">线上使用</a></p>\n"},{"layout":"default","id":"tip2-redux","title":"redux-connect组件的redux坑","prev":"tip1-react-init.html","next":"tip3-inject-global.html","_content":"\n\n使用redux-connect进行数据初始化，如果这个key和自定义的mapStateToProps的props属性有冲突，那么key定义的数据将会更优先\n\n下面例子，定义了初始化的props属性foo，然后mapStateToProps也定义了返回的props.foo的新value，但是，其实dispatch后props.foo还是最开始的\"bar\"，而不是\"bar again\"。\n\n```javascript\nvar {asyncConnect, colaReducer, store} = require('koa-cola').Decorators.view;\n@asyncConnect([\n  {\n    key: 'foo',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n        return await Promise.resolve('bar');\n    }\n  }\n], // mapStateToProps\n({ fooState }) => {\n    return {\n        foo : fooState\n    };\n}, dispatch => {\n    return {\n        changeFoo: () => {\n            dispatch({\n                type: 'CHANGE_FOO'\n            });\n        }\n    };\n})\n@colaReducer({\n    fooState : (state = '', action) => {\n        switch (action.type) {\n            case 'CHANGE_FOO':\n                return 'bar again';\n            default:\n                return state;\n        }\n    }\n})\nclass Some_Page extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>\n        {this.props.foo}\n        <button onClick={() => this.props.changeFoo()}>change foo</button>\n    </div>;\n  }\n}\nexport default Some_Page;\n```\n\n如果必须要修改props.foo，可以使用下面的方法。\n\n```javascript\nvar loadSuccess = store.loadSuccess;\n...\n...\nchangeFoo: () => {\n    dispatch(loadSuccess('foo', 'bar again'));\n}\n```","source":"tip2-redux.md","raw":"---\nlayout: default\nid: tip2-redux\ntitle: redux-connect组件的redux坑\nprev: tip1-react-init.html\nnext: tip3-inject-global.html\n---\n\n\n使用redux-connect进行数据初始化，如果这个key和自定义的mapStateToProps的props属性有冲突，那么key定义的数据将会更优先\n\n下面例子，定义了初始化的props属性foo，然后mapStateToProps也定义了返回的props.foo的新value，但是，其实dispatch后props.foo还是最开始的\"bar\"，而不是\"bar again\"。\n\n```javascript\nvar {asyncConnect, colaReducer, store} = require('koa-cola').Decorators.view;\n@asyncConnect([\n  {\n    key: 'foo',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n        return await Promise.resolve('bar');\n    }\n  }\n], // mapStateToProps\n({ fooState }) => {\n    return {\n        foo : fooState\n    };\n}, dispatch => {\n    return {\n        changeFoo: () => {\n            dispatch({\n                type: 'CHANGE_FOO'\n            });\n        }\n    };\n})\n@colaReducer({\n    fooState : (state = '', action) => {\n        switch (action.type) {\n            case 'CHANGE_FOO':\n                return 'bar again';\n            default:\n                return state;\n        }\n    }\n})\nclass Some_Page extends React.Component<Props, States> {\n  constructor(props: Props) {\n    super(props);\n  }\n  render() {\n    return <div>\n        {this.props.foo}\n        <button onClick={() => this.props.changeFoo()}>change foo</button>\n    </div>;\n  }\n}\nexport default Some_Page;\n```\n\n如果必须要修改props.foo，可以使用下面的方法。\n\n```javascript\nvar loadSuccess = store.loadSuccess;\n...\n...\nchangeFoo: () => {\n    dispatch(loadSuccess('foo', 'bar again'));\n}\n```","date":"2017-08-11T03:02:44.848Z","updated":"2017-08-11T03:02:44.848Z","path":"tip2-redux.html","comments":1,"_id":"cj67atjd5000in4ivjcgg4c1n","content":"<p>使用redux-connect进行数据初始化，如果这个key和自定义的mapStateToProps的props属性有冲突，那么key定义的数据将会更优先</p>\n<p>下面例子，定义了初始化的props属性foo，然后mapStateToProps也定义了返回的props.foo的新value，但是，其实dispatch后props.foo还是最开始的”bar”，而不是”bar again”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;asyncConnect, colaReducer, store&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'foo'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">], <span class=\"comment\">// mapStateToProps</span></div><div class=\"line\">(&#123; fooState &#125;) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        foo : fooState</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;, dispatch =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        changeFoo: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            dispatch(&#123;</div><div class=\"line\">                type: <span class=\"string\">'CHANGE_FOO'</span></div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)</div><div class=\"line\">@colaReducer(&#123;</div><div class=\"line\">    fooState : <span class=\"function\">(<span class=\"params\">state = <span class=\"string\">''</span>, action</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'CHANGE_FOO'</span>:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">'bar again'</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">return</span> state;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some_Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">        &#123;this.props.foo&#125;</div><div class=\"line\">        &lt;button onClick=&#123;() =&gt; this.props.changeFoo()&#125;&gt;change foo&lt;/button&gt;</div><div class=\"line\">    &lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Some_Page;</div></pre></td></tr></table></figure>\n<p>如果必须要修改props.foo，可以使用下面的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> loadSuccess = store.loadSuccess;</div><div class=\"line\">...</div><div class=\"line\">...</div><div class=\"line\">changeFoo: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    dispatch(loadSuccess(<span class=\"string\">'foo'</span>, <span class=\"string\">'bar again'</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<p>使用redux-connect进行数据初始化，如果这个key和自定义的mapStateToProps的props属性有冲突，那么key定义的数据将会更优先</p>\n<p>下面例子，定义了初始化的props属性foo，然后mapStateToProps也定义了返回的props.foo的新value，但是，其实dispatch后props.foo还是最开始的”bar”，而不是”bar again”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;asyncConnect, colaReducer, store&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'foo'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">], <span class=\"comment\">// mapStateToProps</span></div><div class=\"line\">(&#123; fooState &#125;) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        foo : fooState</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;, dispatch =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        changeFoo: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            dispatch(&#123;</div><div class=\"line\">                type: <span class=\"string\">'CHANGE_FOO'</span></div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)</div><div class=\"line\">@colaReducer(&#123;</div><div class=\"line\">    fooState : <span class=\"function\">(<span class=\"params\">state = <span class=\"string\">''</span>, action</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'CHANGE_FOO'</span>:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">'bar again'</span>;</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">return</span> state;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some_Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;div&gt;</div><div class=\"line\">        &#123;this.props.foo&#125;</div><div class=\"line\">        &lt;button onClick=&#123;() =&gt; this.props.changeFoo()&#125;&gt;change foo&lt;/button&gt;</div><div class=\"line\">    &lt;/div&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Some_Page;</div></pre></td></tr></table></figure>\n<p>如果必须要修改props.foo，可以使用下面的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> loadSuccess = store.loadSuccess;</div><div class=\"line\">...</div><div class=\"line\">...</div><div class=\"line\">changeFoo: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    dispatch(loadSuccess(<span class=\"string\">'foo'</span>, <span class=\"string\">'bar again'</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"default","id":"universal","title":"Universal 前后端全栈开发","prev":"compare-next.html","next":"d-mvc.html","_content":"\n### 前后端router\n\n通过controller生成server端的react-router，并且也生成client端的react-reduxt的Provider(里面还是封装了react-router)\n\n```javascript\n@Controller('') \nclass FooController {\n    @Get('/')\n    @View('index')\n    index(@Ctx() ctx) {\n        return '<h1>hello koa-cola !</h1>'\n    }\n}\n```\n自动生成的server端的react-router:\n\n```html\n<Router ... >\n    <Route path=\"/\" component={IndexComponent} />\n</Router>\n```\n\n通过react-router的match到对应的route后，再通过Provider，最终渲染出html：\n```html\n<Provider store={store} key=\"provider\">\n    <SomeReduxComponent />\n</Provider>\n```\n\n\nclient端Provider则是:\n```html\n<Provider store={store} key=\"provider\">\n    <Router ... >\n        <Route path=\"/\" component={IndexComponent} />\n    </Router>\n</Provider>\n```\n\n### 前后端redux\n\nkoa-cola集成了react-redux方案\n\nserver端redux:\n\n#### controller返回props+普通react组件\n\nreact组件最终会转换成react-redux组件，在生命周期的render之前，你可以使用redux比如dispatch。\n\n```javascript\n@Get('/view')\n@View('some_view')\nasync view( @Ctx() ctx ) { // controller返回数据传递到react组件的props.ctrl\n    return await Promise.resolve({\n        foo : 'bar'\n    });\n} \n```\n\nreact组件：\n\n```javascript\nfunction({ctrl : {foo}}){\n    return <div>{foo}</div>\n}\n```\n\n或者\n\n```javascript\nclass Page extends React.Component<Props, States>   {\n    constructor(props: Props) {\n        super(props);\n    }\n    render() {\n        return <div>{this.props.ctrl.foo}</div>\n    }\n};\n```\n#### 使用react-redux组件，但是无法获得controller返回的props\n\n```javascript\nimport { connect } from 'react-redux'\nvar Index = function({some_props}) {\n    return <h1>Wow koa-cola!</h1>\n}\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(Index)\n```\n\n或者是经过redux-connect封装的react-redux:\n\n```javascript\nvar {\n    asyncConnect,\n} = require('koa-cola').Decorators.view;\n\n@asyncConnect(\n[{\n    key: 'foo',\n    promise: async ({ params, helpers}) => {\n        return await Promise.resolve('this will go to this.props.some_props')\n    }\n}],\nmapStateToProps,\nmapDispatchToProps\n)\nclass Index extends React.Component<Props, States>   {\n    constructor(props: Props) {\n        super(props);\n    }\n    render() {\n        return <h1>{this.props.foo}</h1>\n    }\n};\nexport default Index\n```\n\nclient端的redux\n\n在client可以使用上面所有形式的react组件的redux数据流开发模式，并且没有server端只能在render前使用的限制，可以在组件的生命周期任何时候使用。\n\n但是client端的redux store会依赖server端，如果server端的store已经经过一系列的数据流操作，那么将会在render阶段之前的数据保存起来，作为client端react-redux的初始化数据（详细查看[redux的createStore](http://redux.js.org/docs/api/createStore.html)），那么这样就可以完美地redux数据流从server端无缝衔接到client端。\n\n### react组件的前后端复用\n\n从前面react-router和react-redux可以看到react组件是可以完全前后端复用，在前端可以使用react所有功能，但是在server端只能使用render之前的生命周期，包括：\n\n* constructor()\n* componentWillMount()\n* render()\n\n如果你的组件会依赖浏览器的dom，如果是在以上生命周期里面调用，则在server端渲染时出错，所以避免出错，你需要判断当前环境，比如：`if(typeof window != 'undefined')`，或者你可以使用这个类似[模拟浏览器端方案](https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md)。\n\n### http api和请求fetch\n\n在前面[Model](#model)的介绍，也说到过可以使用koa-cola定义的api基类来创建自己的api类，并使用api的fetch方法获取数据：\n\n```javascript\nvar api = new GetTodoList({});\nvar data = await api.fetch(helpers.ctx);\n```\n\n上面代码也是可以兼容server端和服务器端，ajax库使用了[axios](https://github.com/mzabriskie/axios)，比如todolist demo有个react组件定义：\n\n```javascript\n@asyncConnect([\n  {\n    key: 'todosData',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n      var api = new GetTodoList({});\n      var data = await api.fetch(helpers.ctx);\n      return data.result.result;\n    }\n  }\n])\nclass Page extends React.Component<Props, States> {\n  ...\n}\nexport default Page;\n```\n如果该组件的路由是服务器端直接渲染，则`api.fetch`会在服务器端调用，如果该组件是在浏览器端的<Link>跳转，则`api.fetch`会在浏览器端调用。","source":"universal.md","raw":"---\nlayout: default\nid: universal\ntitle: Universal 前后端全栈开发\nprev: compare-next.html\nnext: d-mvc.html\n---\n\n### 前后端router\n\n通过controller生成server端的react-router，并且也生成client端的react-reduxt的Provider(里面还是封装了react-router)\n\n```javascript\n@Controller('') \nclass FooController {\n    @Get('/')\n    @View('index')\n    index(@Ctx() ctx) {\n        return '<h1>hello koa-cola !</h1>'\n    }\n}\n```\n自动生成的server端的react-router:\n\n```html\n<Router ... >\n    <Route path=\"/\" component={IndexComponent} />\n</Router>\n```\n\n通过react-router的match到对应的route后，再通过Provider，最终渲染出html：\n```html\n<Provider store={store} key=\"provider\">\n    <SomeReduxComponent />\n</Provider>\n```\n\n\nclient端Provider则是:\n```html\n<Provider store={store} key=\"provider\">\n    <Router ... >\n        <Route path=\"/\" component={IndexComponent} />\n    </Router>\n</Provider>\n```\n\n### 前后端redux\n\nkoa-cola集成了react-redux方案\n\nserver端redux:\n\n#### controller返回props+普通react组件\n\nreact组件最终会转换成react-redux组件，在生命周期的render之前，你可以使用redux比如dispatch。\n\n```javascript\n@Get('/view')\n@View('some_view')\nasync view( @Ctx() ctx ) { // controller返回数据传递到react组件的props.ctrl\n    return await Promise.resolve({\n        foo : 'bar'\n    });\n} \n```\n\nreact组件：\n\n```javascript\nfunction({ctrl : {foo}}){\n    return <div>{foo}</div>\n}\n```\n\n或者\n\n```javascript\nclass Page extends React.Component<Props, States>   {\n    constructor(props: Props) {\n        super(props);\n    }\n    render() {\n        return <div>{this.props.ctrl.foo}</div>\n    }\n};\n```\n#### 使用react-redux组件，但是无法获得controller返回的props\n\n```javascript\nimport { connect } from 'react-redux'\nvar Index = function({some_props}) {\n    return <h1>Wow koa-cola!</h1>\n}\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(Index)\n```\n\n或者是经过redux-connect封装的react-redux:\n\n```javascript\nvar {\n    asyncConnect,\n} = require('koa-cola').Decorators.view;\n\n@asyncConnect(\n[{\n    key: 'foo',\n    promise: async ({ params, helpers}) => {\n        return await Promise.resolve('this will go to this.props.some_props')\n    }\n}],\nmapStateToProps,\nmapDispatchToProps\n)\nclass Index extends React.Component<Props, States>   {\n    constructor(props: Props) {\n        super(props);\n    }\n    render() {\n        return <h1>{this.props.foo}</h1>\n    }\n};\nexport default Index\n```\n\nclient端的redux\n\n在client可以使用上面所有形式的react组件的redux数据流开发模式，并且没有server端只能在render前使用的限制，可以在组件的生命周期任何时候使用。\n\n但是client端的redux store会依赖server端，如果server端的store已经经过一系列的数据流操作，那么将会在render阶段之前的数据保存起来，作为client端react-redux的初始化数据（详细查看[redux的createStore](http://redux.js.org/docs/api/createStore.html)），那么这样就可以完美地redux数据流从server端无缝衔接到client端。\n\n### react组件的前后端复用\n\n从前面react-router和react-redux可以看到react组件是可以完全前后端复用，在前端可以使用react所有功能，但是在server端只能使用render之前的生命周期，包括：\n\n* constructor()\n* componentWillMount()\n* render()\n\n如果你的组件会依赖浏览器的dom，如果是在以上生命周期里面调用，则在server端渲染时出错，所以避免出错，你需要判断当前环境，比如：`if(typeof window != 'undefined')`，或者你可以使用这个类似[模拟浏览器端方案](https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md)。\n\n### http api和请求fetch\n\n在前面[Model](#model)的介绍，也说到过可以使用koa-cola定义的api基类来创建自己的api类，并使用api的fetch方法获取数据：\n\n```javascript\nvar api = new GetTodoList({});\nvar data = await api.fetch(helpers.ctx);\n```\n\n上面代码也是可以兼容server端和服务器端，ajax库使用了[axios](https://github.com/mzabriskie/axios)，比如todolist demo有个react组件定义：\n\n```javascript\n@asyncConnect([\n  {\n    key: 'todosData',\n    promise: async ({ params, helpers, store: { dispatch } }) => {\n      var api = new GetTodoList({});\n      var data = await api.fetch(helpers.ctx);\n      return data.result.result;\n    }\n  }\n])\nclass Page extends React.Component<Props, States> {\n  ...\n}\nexport default Page;\n```\n如果该组件的路由是服务器端直接渲染，则`api.fetch`会在服务器端调用，如果该组件是在浏览器端的<Link>跳转，则`api.fetch`会在浏览器端调用。","date":"2017-08-07T09:39:08.377Z","updated":"2017-08-07T09:39:08.377Z","path":"universal.html","comments":1,"_id":"cj67atjd5000jn4ivf8npfy20","content":"<h3 id=\"前后端router\"><a href=\"#前后端router\" class=\"headerlink\" title=\"前后端router\"></a>前后端router</h3><p>通过controller生成server端的react-router，并且也生成client端的react-reduxt的Provider(里面还是封装了react-router)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Controller(<span class=\"string\">''</span>) </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span> </span>&#123;</div><div class=\"line\">    @Get(<span class=\"string\">'/'</span>)</div><div class=\"line\">    @View(<span class=\"string\">'index'</span>)</div><div class=\"line\">    index(@Ctx() ctx) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;h1&gt;hello koa-cola !&lt;/h1&gt;'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>自动生成的server端的react-router:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">...</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;IndexComponent&#125;</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>通过react-router的match到对应的route后，再通过Provider，最终渲染出html：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Provider</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">\"provider\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">SomeReduxComponent</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Provider</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>client端Provider则是:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Provider</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">\"provider\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">...</span> &gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;IndexComponent&#125;</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Provider</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"前后端redux\"><a href=\"#前后端redux\" class=\"headerlink\" title=\"前后端redux\"></a>前后端redux</h3><p>koa-cola集成了react-redux方案</p>\n<p>server端redux:</p>\n<h4 id=\"controller返回props-普通react组件\"><a href=\"#controller返回props-普通react组件\" class=\"headerlink\" title=\"controller返回props+普通react组件\"></a>controller返回props+普通react组件</h4><p>react组件最终会转换成react-redux组件，在生命周期的render之前，你可以使用redux比如dispatch。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Get(<span class=\"string\">'/view'</span>)</div><div class=\"line\">@View(<span class=\"string\">'some_view'</span>)</div><div class=\"line\"><span class=\"keyword\">async</span> view( @Ctx() ctx ) &#123; <span class=\"comment\">// controller返回数据传递到react组件的props.ctrl</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(&#123;</div><div class=\"line\">        foo : <span class=\"string\">'bar'</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>react组件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;ctrl : &#123;foo&#125;&#125;</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt;   </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    &#125;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.ctrl.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"使用react-redux组件，但是无法获得controller返回的props\"><a href=\"#使用react-redux组件，但是无法获得controller返回的props\" class=\"headerlink\" title=\"使用react-redux组件，但是无法获得controller返回的props\"></a>使用react-redux组件，但是无法获得controller返回的props</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></div><div class=\"line\"><span class=\"keyword\">var</span> Index = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;some_props&#125;</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Wow koa-cola!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</div><div class=\"line\">    mapStateToProps,</div><div class=\"line\">    mapDispatchToProps</div><div class=\"line\">)(Index)</div></pre></td></tr></table></figure>\n<p>或者是经过redux-connect封装的react-redux:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">    asyncConnect,</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\"></div><div class=\"line\">@asyncConnect(</div><div class=\"line\">[&#123;</div><div class=\"line\">    key: <span class=\"string\">'foo'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers&#125;) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'this will go to this.props.some_props'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;],</div><div class=\"line\">mapStateToProps,</div><div class=\"line\">mapDispatchToProps</div><div class=\"line\">)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt;   </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    &#125;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Index</div></pre></td></tr></table></figure>\n<p>client端的redux</p>\n<p>在client可以使用上面所有形式的react组件的redux数据流开发模式，并且没有server端只能在render前使用的限制，可以在组件的生命周期任何时候使用。</p>\n<p>但是client端的redux store会依赖server端，如果server端的store已经经过一系列的数据流操作，那么将会在render阶段之前的数据保存起来，作为client端react-redux的初始化数据（详细查看<a href=\"http://redux.js.org/docs/api/createStore.html\" target=\"_blank\" rel=\"external\">redux的createStore</a>），那么这样就可以完美地redux数据流从server端无缝衔接到client端。</p>\n<h3 id=\"react组件的前后端复用\"><a href=\"#react组件的前后端复用\" class=\"headerlink\" title=\"react组件的前后端复用\"></a>react组件的前后端复用</h3><p>从前面react-router和react-redux可以看到react组件是可以完全前后端复用，在前端可以使用react所有功能，但是在server端只能使用render之前的生命周期，包括：</p>\n<ul>\n<li>constructor()</li>\n<li>componentWillMount()</li>\n<li>render()</li>\n</ul>\n<p>如果你的组件会依赖浏览器的dom，如果是在以上生命周期里面调用，则在server端渲染时出错，所以避免出错，你需要判断当前环境，比如：<code>if(typeof window != &#39;undefined&#39;)</code>，或者你可以使用这个类似<a href=\"https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md\" target=\"_blank\" rel=\"external\">模拟浏览器端方案</a>。</p>\n<h3 id=\"http-api和请求fetch\"><a href=\"#http-api和请求fetch\" class=\"headerlink\" title=\"http api和请求fetch\"></a>http api和请求fetch</h3><p>在前面<a href=\"#model\">Model</a>的介绍，也说到过可以使用koa-cola定义的api基类来创建自己的api类，并使用api的fetch方法获取数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div></pre></td></tr></table></figure>\n<p>上面代码也是可以兼容server端和服务器端，ajax库使用了<a href=\"https://github.com/mzabriskie/axios\" target=\"_blank\" rel=\"external\">axios</a>，比如todolist demo有个react组件定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'todosData'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\">      <span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div><div class=\"line\">      <span class=\"keyword\">return</span> data.result.result;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Page;</div></pre></td></tr></table></figure>\n<p>如果该组件的路由是服务器端直接渲染，则<code>api.fetch</code>会在服务器端调用，如果该组件是在浏览器端的<link>跳转，则<code>api.fetch</code>会在浏览器端调用。</p>\n","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":"<h3 id=\"前后端router\"><a href=\"#前后端router\" class=\"headerlink\" title=\"前后端router\"></a>前后端router</h3><p>通过controller生成server端的react-router，并且也生成client端的react-reduxt的Provider(里面还是封装了react-router)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Controller(<span class=\"string\">''</span>) </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span> </span>&#123;</div><div class=\"line\">    @Get(<span class=\"string\">'/'</span>)</div><div class=\"line\">    @View(<span class=\"string\">'index'</span>)</div><div class=\"line\">    index(@Ctx() ctx) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;h1&gt;hello koa-cola !&lt;/h1&gt;'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>自动生成的server端的react-router:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">...</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;IndexComponent&#125;</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>通过react-router的match到对应的route后，再通过Provider，最终渲染出html：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Provider</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">\"provider\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">SomeReduxComponent</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Provider</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>client端Provider则是:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Provider</span> <span class=\"attr\">store</span>=<span class=\"string\">&#123;store&#125;</span> <span class=\"attr\">key</span>=<span class=\"string\">\"provider\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">...</span> &gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;IndexComponent&#125;</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Provider</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"前后端redux\"><a href=\"#前后端redux\" class=\"headerlink\" title=\"前后端redux\"></a>前后端redux</h3><p>koa-cola集成了react-redux方案</p>\n<p>server端redux:</p>\n<h4 id=\"controller返回props-普通react组件\"><a href=\"#controller返回props-普通react组件\" class=\"headerlink\" title=\"controller返回props+普通react组件\"></a>controller返回props+普通react组件</h4><p>react组件最终会转换成react-redux组件，在生命周期的render之前，你可以使用redux比如dispatch。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Get(<span class=\"string\">'/view'</span>)</div><div class=\"line\">@View(<span class=\"string\">'some_view'</span>)</div><div class=\"line\"><span class=\"keyword\">async</span> view( @Ctx() ctx ) &#123; <span class=\"comment\">// controller返回数据传递到react组件的props.ctrl</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(&#123;</div><div class=\"line\">        foo : <span class=\"string\">'bar'</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>react组件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;ctrl : &#123;foo&#125;&#125;</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt;   </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    &#125;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.props.ctrl.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"使用react-redux组件，但是无法获得controller返回的props\"><a href=\"#使用react-redux组件，但是无法获得controller返回的props\" class=\"headerlink\" title=\"使用react-redux组件，但是无法获得controller返回的props\"></a>使用react-redux组件，但是无法获得controller返回的props</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></div><div class=\"line\"><span class=\"keyword\">var</span> Index = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123;some_props&#125;</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Wow koa-cola!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</div><div class=\"line\">    mapStateToProps,</div><div class=\"line\">    mapDispatchToProps</div><div class=\"line\">)(Index)</div></pre></td></tr></table></figure>\n<p>或者是经过redux-connect封装的react-redux:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;</div><div class=\"line\">    asyncConnect,</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-cola'</span>).Decorators.view;</div><div class=\"line\"></div><div class=\"line\">@asyncConnect(</div><div class=\"line\">[&#123;</div><div class=\"line\">    key: <span class=\"string\">'foo'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers&#125;) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'this will go to this.props.some_props'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;],</div><div class=\"line\">mapStateToProps,</div><div class=\"line\">mapDispatchToProps</div><div class=\"line\">)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Index</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt;   </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(props: Props) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    &#125;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Index</div></pre></td></tr></table></figure>\n<p>client端的redux</p>\n<p>在client可以使用上面所有形式的react组件的redux数据流开发模式，并且没有server端只能在render前使用的限制，可以在组件的生命周期任何时候使用。</p>\n<p>但是client端的redux store会依赖server端，如果server端的store已经经过一系列的数据流操作，那么将会在render阶段之前的数据保存起来，作为client端react-redux的初始化数据（详细查看<a href=\"http://redux.js.org/docs/api/createStore.html\" target=\"_blank\" rel=\"external\">redux的createStore</a>），那么这样就可以完美地redux数据流从server端无缝衔接到client端。</p>\n<h3 id=\"react组件的前后端复用\"><a href=\"#react组件的前后端复用\" class=\"headerlink\" title=\"react组件的前后端复用\"></a>react组件的前后端复用</h3><p>从前面react-router和react-redux可以看到react组件是可以完全前后端复用，在前端可以使用react所有功能，但是在server端只能使用render之前的生命周期，包括：</p>\n<ul>\n<li>constructor()</li>\n<li>componentWillMount()</li>\n<li>render()</li>\n</ul>\n<p>如果你的组件会依赖浏览器的dom，如果是在以上生命周期里面调用，则在server端渲染时出错，所以避免出错，你需要判断当前环境，比如：<code>if(typeof window != &#39;undefined&#39;)</code>，或者你可以使用这个类似<a href=\"https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md\" target=\"_blank\" rel=\"external\">模拟浏览器端方案</a>。</p>\n<h3 id=\"http-api和请求fetch\"><a href=\"#http-api和请求fetch\" class=\"headerlink\" title=\"http api和请求fetch\"></a>http api和请求fetch</h3><p>在前面<a href=\"#model\">Model</a>的介绍，也说到过可以使用koa-cola定义的api基类来创建自己的api类，并使用api的fetch方法获取数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div></pre></td></tr></table></figure>\n<p>上面代码也是可以兼容server端和服务器端，ajax库使用了<a href=\"https://github.com/mzabriskie/axios\" target=\"_blank\" rel=\"external\">axios</a>，比如todolist demo有个react组件定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncConnect([</div><div class=\"line\">  &#123;</div><div class=\"line\">    key: <span class=\"string\">'todosData'</span>,</div><div class=\"line\">    promise: <span class=\"keyword\">async</span> (&#123; params, helpers, <span class=\"attr\">store</span>: &#123; dispatch &#125; &#125;) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> api = <span class=\"keyword\">new</span> GetTodoList(&#123;&#125;);</div><div class=\"line\">      <span class=\"keyword\">var</span> data = <span class=\"keyword\">await</span> api.fetch(helpers.ctx);</div><div class=\"line\">      <span class=\"keyword\">return</span> data.result.result;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">])</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Page</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, <span class=\"title\">States</span>&gt; </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Page;</div></pre></td></tr></table></figure>\n<p>如果该组件的路由是服务器端直接渲染，则<code>api.fetch</code>会在服务器端调用，如果该组件是在浏览器端的<link>跳转，则<code>api.fetch</code>会在浏览器端调用。</p>\n"},{"layout":"default","id":"views-app","title":"views/app.tsx","prev":"views-pages.html","next":"views-components.html","_content":"","source":"views-app.md","raw":"---\nlayout: default\nid: views-app\ntitle: views/app.tsx\nprev: views-pages.html\nnext: views-components.html\n---","date":"2017-08-11T03:13:26.471Z","updated":"2017-08-11T03:13:26.471Z","path":"views-app.html","comments":1,"_id":"cj67atjd6000kn4ivelavbjz7","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"views-components","title":"views/components","prev":"views-app.html","_content":"","source":"views-components.md","raw":"---\nlayout: default\nid: views-components\ntitle: views/components\nprev: views-app.html\n---","date":"2017-08-11T03:13:35.566Z","updated":"2017-08-11T03:13:35.566Z","path":"views-components.html","comments":1,"_id":"cj67atjd7000ln4ivvnqpyaor","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"views-pages","title":"views/pages","prev":"views.html","next":"views-app.html","_content":"","source":"views-pages.md","raw":"---\nlayout: default\nid: views-pages\ntitle: views/pages\nprev: views.html\nnext: views-app.html\n---","date":"2017-08-11T03:13:08.408Z","updated":"2017-08-11T03:13:08.408Z","path":"views-pages.html","comments":1,"_id":"cj67atjd9000mn4ivvpdi1k4p","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""},{"layout":"default","id":"views","title":"views","prev":"config/env.html","next":"views-pages.html","_content":"","source":"views.md","raw":"---\nlayout: default\nid: views\ntitle: views\nprev: config/env.html\nnext: views-pages.html\n---","date":"2017-08-11T03:12:50.601Z","updated":"2017-08-11T03:12:50.601Z","path":"views.html","comments":1,"_id":"cj67atjd9000nn4ivm40fqxfy","content":"","site":{"data":{"nav":[{"title":"介绍","items":[{"id":"index","title":"koa-cola是什么?"},{"id":"ssr","title":"SSR和SPA"},{"id":"compare-next","title":"对比next.js"},{"id":"universal","title":"Universal 前后端全栈开发"},{"id":"d-mvc","title":"decorator的mvc开发模式"}]},{"title":"使用方法","items":[{"id":"installation","title":"如何使用"},{"id":"cli","title":"Cli命令"}]},{"title":"在线演示","items":[{"id":"demo-todolist","title":"todolist例子"}]},{"title":"目录结构","items":[{"id":"api-controllers","title":"api/controllers"},{"id":"api-models","title":"api/models"},{"id":"api-schemas","title":"api/schemas"},{"id":"api-responses","title":"api/responses"},{"id":"config","title":"config"},{"id":"config-env","title":"config/env"},{"id":"public","title":"public"},{"id":"views","title":"views"},{"id":"views-pages","title":"views/pages"},{"id":"views-app","title":"views/app.tsx"},{"id":"views-components","title":"views/components"}]},{"title":"Tips","items":[{"id":"tip1-react-init","title":"初始化react组件数据"},{"id":"tip2-redux","title":"redux-connect组件的redux坑"},{"id":"tip3-inject-global","title":"Inject global全局注入"},{"id":"tip4-cluster","title":"cluster集群模式"},{"id":"tip5-debug","title":"调试"},{"id":"tip6-compile","title":"代码编译"}]}]}},"excerpt":"","more":""}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}